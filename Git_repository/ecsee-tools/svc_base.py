#!/usr/bin/python

# Copyright (c) 2016 EMC Corporation
# All Rights Reserved
#
# This software contains the intellectual property of EMC Corporation
# or is licensed to EMC Corporation from third parties.  Use of this
# software and the intellectual property contained therein is expressly
# limited to the terms and conditions of the License Agreement under which
# it is provided by or on behalf of EMC.

import subprocess
import socket
import sys
import os
import re
import json
import datetime
import commands
import fcntl
import struct
import logging
from subprocess import Popen, PIPE
from time import sleep, time


class Common:
    """
    Base class for use in EE scripts. This class should contain all the common functions you will need to script an EE
    process. If you have suggestions or find a bug please forward it to Ian Schorr or Shawn Roche
    """

    def __init__(self, tool_name):
        """
        :param tool_name: name of the tool the base class is being used in. EX: svc_patch, svc_network, etc.
                          Used only in log file naming at the moment
        """
        self.tool_name = tool_name
        self.today = datetime.date.today()
        self.logging_init()
        self.verbose = 0
        self.Global_LogMessage = False
        self.rack_info = self.get_rack_info()
        self.machines = [self.rack_info[node]['private'] for node in self.rack_info]
        self.machines_file_name = os.path.expanduser('~/MACHINES')
        self.colors = BColors()

    def logging_init(self):
        # cwd = os.getcwd()
        # os.chdir(self.app_path)
        logging.basicConfig(filename='{}_{}.log'.format(self.tool_name, self.today),
                            filemode='a',
                            format="%(asctime)-15s [%(levelname)8s] %(message)s",
                            level=logging.DEBUG
                            )

        logging.info('=' * 40)
        logging.info('New Run'.center(40))
        logging.info('=' * 40)

        # os.chdir(cwd)

    def get_rack_info(self, skip_checks=False):
        """
        Generate a dict out of getrackinfo and getrackinfo -v.

        :param skip_checks: Skip validating the data generated by getrackinfo before returning. Not recommended to use
        :type skip_checks: bool
        :return: Each node will have a dict with its name, rack, number and all the necessary IPs. ex:
                {'1': {
                    'id': '1',
                    'name': 'provo',
                    'rack': 'green',
                    'role': 'master',
                    'public': '127.0.0.1',
                    'private': '127.0.0.1',
                    'private.4': '127.0.0.1',
                    'private_ipmi': '127.0.0.1',
                    'remote_ipmi': '127.0.0.1'
                }}
        :rtype: dict
        """
        # global MACHINES
        # if MACHINES is None or force is True:

        # Query the list of MACHINES in the current rack from the system.
        rack_info = {}
        num = '1'
        error_text = ''
        # Build a dict of the nodes with their names, IPs, and role from getrackinfo -v.
        # For each node we'll set the default value of every key to ERROR to make checking for data that failed to
        # retrieve easier
        logging.info('Generating rackinfo dictionary')
        output = iter(self.run_cmd("sudo getrackinfo -v")['stdout'].splitlines())
        for line in output:
            if 'NodeName' in line:
                name = re.search(r": ([a-z]+-[a-z]+)", line).group(1)
                name, rack = name.split('-')
                num = re.search(r": (\d)", next(output)).group(1)
                logging.info('Found node {} ({})'.format(num, name))
                rack_info[num] = {
                    'name': name,
                    'rack': rack,
                    'id': num,
                    'role': 'ERROR',
                    'public': 'ERROR',
                    'private': 'ERROR',
                    'private.4': 'ERROR',
                    'private_ipmi': 'ERROR',
                    'remote_ipmi': 'ERROR'
                }
            elif 'public' in line:
                rack_info[num]['public'] = self.extract_ip(line)[0]
                logging.info('node {} - public IP: {}'.format(num, rack_info[num]['public']))
            elif 'private Ipmi' in line:
                rack_info[num]['private_ipmi'] = self.extract_ip(line)[0]
                logging.info('node {} - private ipmi IP: {}'.format(num, rack_info[num]['private_ipmi']))
            elif 'NAN' in line:
                # rack_info[num]['nan'] = extract_ip(line)
                rack_info[num]['private.4'] = self.extract_ip(line)[0]
                logging.info('node {} - private.4 IP: {}'.format(num, rack_info[num]['private.4']))
            elif 'private' in line:
                rack_info[num]['private'] = self.extract_ip(line)[0]
                logging.info('node {} - private IP: {}'.format(num, rack_info[num]['private']))
            elif 'Remote Ipmi' in line:
                rack_info[num]['remote_ipmi'] = self.extract_ip(line)[0]
                logging.info('node {} - remote ipmi IP: {}'.format(num, rack_info[num]['remote_ipmi']))

        # Since -v doesn't return MA/SA status, use getrackinfo to find the role for each node and add it to the dict
        output = subprocess.check_output(['sudo', 'getrackinfo']).splitlines()
        for line in output:
            vals = line.split()
            try:
                if vals[2] == 'MA':
                    rack_info[vals[1]]['role'] = 'master'
                elif vals[2] == 'SA':
                    rack_info[vals[1]]['role'] = 'slave'
            except IndexError:
                # Ignore IndexError because some of the output we don't use after the list of nodes only has
                # 1 word per line
                break

        # Sanity checks.  Skip checks if user has specified to ignore them.

        # MACHINES list may be returned incorrectly if, say, a node is offline, or
        # for other reasons.

        # XXX - need to be able to get the list of all configured nodes in the VDC
        # Validate the values retrieved a bit before returning the dict
        if skip_checks:
            self.msg_output("Skipping MACHINES sanity check", req_loglevel=1)
            return rack_info

        checks_passed = True
        logging.info('Validating rack info returned by getrackinfo')
        # Check that the number of nodes returned by getrackinfo matches the number returned by the API
        login_cmd = 'curl -ks -H "$(curl -iks -u emcmonitor:ChangeMe https://`hostname -i`:4443/login | ' \
                    'grep -oP "X-SDS.+: \w+=")" https://`hostname -i`:4443/vdc/nodes.json'
        expected_nodes = json.loads(self.run_cmd(login_cmd)['stdout'])

        num_expected_nodes = len(expected_nodes['node'])

        if len(rack_info.keys()) != num_expected_nodes:
            checks_passed = False
            error_text += "ERROR: MACHINES list size is incorrect.  Expected {},\n".format(num_expected_nodes)
            error_text += "  list contains '{}' entries\n".format(len(rack_info.keys()))

        logging.info('Number of nodes returned ({}) is correct'.format(len(rack_info.keys())))
        for node in rack_info:
            # First check if any values were not able to be set and are still set to 'ERROR'
            errors = [x for x in rack_info[node] if rack_info[node][x] == 'ERROR']
            if errors:
                for error in errors:
                    logging.error("Unable to retrieve value for {} of node {}".format(error, node))
                checks_passed = False
            else:
                # vaidate the private IPMI IP
                if "192.168.219." not in rack_info[node]['private_ipmi']:
                    checks_passed = False
                    logging.error("Invalid IPMI IP retrieved: '{}'".format(node['private_ipmi']))

                # Validate the private IP
                if "192.168.219." not in rack_info[node]['private']:
                    checks_passed = False
                    logging.error('Entry in MACHINE list is invalid. Only private network IPs are supported.')
                    logging.error('Expected 192.168.219.x, got {}'.format(node['private_ipmi']))

        if not checks_passed:
            errortext = "There was an error. This may indicate that getrackinfo -v produced an incorrect list,\n" \
                        "  that nodes are offline or unreachable, that a filesystem is full, or the current \n" \
                        "  configuration is unsupported by the script.\n " \
                        "If you believe this is safe to continue, run this script again\n" \
                        "  with the --ignoreMachineChecks flag set.\n"
            self.msg_output(errortext, error=True, newline=True)
            exit(18)
            # End sanity checks

            # XXX - reminder that once we expand to letting the user provide a custom
            #       MACHINES file, do serious sanity checking; we don't want to use a MACHINES
            #       list that specifies systems outside the current VDC, public IPs, etc

        return rack_info

    def get_node(self, target_node):
        """
        Returns the dict of the node requested from self.rack_info.

        :param target_node: Either the number of the node you need or 'current' for the node you are running on
        :type target_node: int, str
        :return: Dict of the node requested
        :rtype: dict
        """
        if not self.rack_info:
            self.rack_info = self.get_rack_info()

        try:
            # Assume the passed node was an int and subtract 1 from it to get the appropriate list index
            target_node = int(target_node) - 1
            node = sorted(self.rack_info.keys())[target_node]
            return self.rack_info[node]
        except ValueError:
            # Catch the error if a string was passed and check if it == 'current'
            if target_node == 'current':
                local_ip = self._get_local_private_ip()
                for node in self.rack_info:
                    if self.rack_info[node]['private'] == local_ip:
                        return self.rack_info[node]['id']

                private_ips = [self.rack_info[node]['private'] for node in self.rack_info]
                error_text = """
                        ERROR: get_current_node(): Unable to match local private IP to node info returned by getrackinfo
                        Local IP returned by ifconfig: {}
                        List of IPs from getrackinfo: {}
                        """.format(local_ip, private_ips)
                self.msg_output(error_text, error=True)
                exit(8)
            else:
                error_text = "Passed target node ({})is not a number or 'current'. " \
                             "Unable to retrieve node info".format(target_node)
                self.msg_output(error_text, error=True)
                exit(8)

    def _get_local_private_ip(self):
        """
        Helper function for _get_node(). Uses ifconfig to get the local IP of the machine being run on

        :return: IP address of local machine
        :rtype: str
        """

        result = self.run_cmd(
            "sudo ifconfig private | grep 'inet addr' | awk -F: '{ print $2 }' | awk '{ print $1 }' | head -1"
        )
        logging.debug('Result: {}'.format(result))

        local_private_ip = result['stdout'].strip()
        logging.debug('Found {} as the local private IP'.format(local_private_ip))

        # Sanity check that the string we got looks valid.
        # XXX - won't work with private networks that have been changed from default - is a problem?
        if "192.168.219." not in local_private_ip:
            self.msg_output("ERROR:  Could not determine a valid local private IP address.", error=True)
            self.msg_output("Expected format '192.168.219.x', received '{}'".format(local_private_ip), error=True)
            self.msg_output("Exiting...", error=True)
            exit(7)

        return local_private_ip

    def run_cmd(self, command, printText="", printComplete=False, noErrorHandling=False, showWarnings=True, indent=0,
                realtime=False, do_LogMessage=False, no_LogMessage=False, print_Verbose=True, MACHINE=None,
                timeout=None, container=False, do_sudo=False):
        """
        Run commands and return the results. By default, we will execute the command synchronously - we will stop,
        wait for it to exit, and resume processing when it does.

        Will pass through "showWarnings" and "indent" options to handle_cmd_error() and
        msg/self.err_output(), respectively.

        Currently there's a limitation with "realtime mode" where it may not print stderr output
        in the order it was generated - we may print stdout lines before we print stderr lines generated
        by the called command.

        :param command: String. Command to be run
        :param printText:
        :param printComplete:
        :param noErrorHandling: Bool. Do not try to process any errors if one is encountered, just return output
        :param showWarnings:
        :param indent: Int. Number of 4 space indents to prepend to any messages created
        :param realtime: Bool. Flag to print stdout and stderr as they are generated. Useful when the script needs to
        see and/or display the output of a child script immediately i.e. for refit
        :param do_LogMessage: Bool. Ignore log level and log a message
        :param no_LogMessage: Bool. Ignore log level and do not log anything
        :param print_Verbose: Bool. Flag to print additional output
        :param MACHINE: String. private IP of the node to run the command on
        :param timeout:
        :param container: Bool. Flag to run the commands inside the object-main container of each node
        :param do_sudo: Bool. Flag to run the command with sudo
        :return: Dict with many attributes including
                            ['stdout'] and ['stderr'] - stores complete output of, well, stdout and stderr returned
                            ['retval'] - return value of executed command
                            ['command'] - Full command executed (potentially useful if this package gets passed
                              between functions
                            ['realtime'] - whether or not the command was executed in "realtime" mode, so output was
                              already printed to stdout/stderr
        """
        # XXX - Use subprocess.run() timeout value.  Should caller be able to specify the timeout or should we just
        # use a global failsafe default?  Probably both.
        # XXX - Well, that'd be nice, except of course that didn't show up until python 3, and we're on 2.7.9.
        # Another option for handling indefinitely running commands??  And how do we define the timeout?

        cmdFailed = False
        verboseval = ""
        veryverboseval = ""
        errorval = ""

        sudoicmd = self.get_sudoicmd()

        if MACHINE is not None:  # We're executing against a remote node
            ContainerOption = ""
            if container:  # Run inside the container
                ContainerOption = "-c "
            command = "{}/tools/viprexec-upgrade {} -n {} '{}'".format(
                self.upgrade,
                ContainerOption,
                MACHINE,
                command
            )

        if timeout is not None:  # We want to time out the command after a given amount of time
            command = " timeout --kill-after=10 {} sh -c '{}'".format(timeout, self.encapsulate_shell_cmd(command))

        if do_sudo:
            command = sudoicmd + " " + command

        if printText:
            # When running the command, we're going to print an output like
            #   "Checking for version of Node..."
            # which will be followed later by "DONE" or "FAILED".
            self.msg_output(printText, no_LogMessage=no_LogMessage, newline=False)

            if printComplete:
                # We're going to be printing a colorized "DONE" or "FAILED" once the
                # command completes, followed by error and verbose text (if any)
                temp = 1

            else:
                # We're being asked not to print/log completion info or error/verbose info
                # at this time.  This will be printed later after parsing the output.
                no_LogMessage = True
                print_Verbose = False
                noErrorHandling = True

            verboseval += self.msg_output("\nCommand run: " + command, indent=indent, no_LogMessage=True,
                                          print_Text=False)
        else:
            self.msg_output("\nCommand run: " + command, indent=indent, req_loglevel=1, no_LogMessage=no_LogMessage,
                            print_Text=print_Verbose)

        if realtime:
            print_Verbose = False

        p = Popen(command, shell=True, stdout=PIPE, stderr=PIPE, bufsize=1)
        # print p.communicate()
        #
        stdout = ""
        stderr = ""

        if realtime:
            while True:
                out = p.stdout.read(1)
                if out == '' and p.poll() != None:  # p.poll checks if process has terminated
                    break
                if out != '':
                    stdout = stdout + out
                    self.msg_output(out, newline=False, do_LogMessage=do_LogMessage, no_LogMessage=no_LogMessage,
                                    indent=indent)
            # means stderr will always be included after stdout...hmmm
            while True:
                err = p.stderr.read(1)
                if err == '' and p.poll():
                    break
                if err != '':
                    stderr = stderr + err

            # Printing full message to work around an issue with ANSI colorizing sequences.
            # Process has already terminated by this point so we don't need to print as we
            # read, loop will read the complete buffer before termminating
            self.msg_output(stderr, do_LogMessage=do_LogMessage, no_LogMessage=no_LogMessage, indent=indent)

            retval = p.poll()

        else:
            stdout, stderr = p.communicate()
            retval = p.returncode

        if MACHINE is not None:
            stdout = stdout.replace("\nOutput from host : " + MACHINE + " \n", '')

        # Very verbose messages:

        veryverboseval += self.msg_output("=================== Verbose output =====================", indent=indent,
                                          no_LogMessage=True, print_Text=False)
        veryverboseval += self.msg_output("Return value: " + str(retval), indent=indent, no_LogMessage=True,
                                          print_Text=False)
        veryverboseval += self.msg_output("Command output:", indent=indent, no_LogMessage=True, print_Text=False)
        veryverboseval += self.msg_output(stdout, indent=indent + 1, no_LogMessage=True, print_Text=False,
                                          newline=False)

        # If errors were returned - stderr was non-zero and there was output text:
        if isinstance(stderr, basestring) and stderr != "":
            cmdFailed = True
            errorval += self.msg_output("stderr:", indent=indent, no_LogMessage=True, print_Text=False)
            errorval += self.msg_output(stderr, indent=indent + 1, no_LogMessage=True, print_Text=False,
                                        newline=False)

        # create return Dictionary
        cmd_output = {'command': command,
                      'stdout': stdout,
                      'stderr': stderr,
                      'retval': retval,
                      'realtime': realtime,
                      'verbose_out': verboseval,
                      'veryverbose_out': veryverboseval,
                      'error_out': errorval, }

        # print "DONE" or "FAILED", if applicable:
        if printText != "" and printComplete:
            if not cmdFailed:
                self.msg_output(self.colors.OK + "DONE" + self.colors.ENDC)
            else:
                self.msg_output(self.colors.FAIL + "FAILED" + self.colors.ENDC)

        # Print verbose and error outputs to screen and log, unless surpressed

        if verboseval.strip() != "" or veryverboseval != "":
            # self.msg_output("=================== Verbose output =====================",
            # do_LogMessage=do_LogMessage,
            # no_LogMessage=no_LogMessage,
            # print_Text=print_Verbose,
            # req_loglevel=1)
            self.msg_output(verboseval, do_LogMessage=do_LogMessage, no_LogMessage=no_LogMessage,
                            print_Text=print_Verbose,
                            req_loglevel=1, newline=False)
            self.msg_output(veryverboseval, do_LogMessage=do_LogMessage, no_LogMessage=no_LogMessage,
                            print_Text=print_Verbose,
                            req_loglevel=2, newline=False)
        if cmdFailed:
            if noErrorHandling:
                self.msg_output(errorval, do_LogMessage=do_LogMessage, no_LogMessage=no_LogMessage,
                                print_Text=print_Verbose,
                                req_loglevel=2)
            else:
                self.msg_output(errorval, do_LogMessage=do_LogMessage, no_LogMessage=no_LogMessage,
                                print_Text=print_Verbose,
                                req_loglevel=2)

        if noErrorHandling == False:
            self.handle_cmd_error(cmd_output, showWarnings=showWarnings)

        return cmd_output

    def run_multi_cmd(self, command, MACHINES=None, Container=False, do_LogMessage=False, no_LogMessage=False,
                      print_Verbose=True, noErrorHandling=False):
        """
        Run a command against every node using viprexec. To make it easy to parse results into an organized Dict,
        runs viprexec one at a time. This is slower than running in parallel and may be improved in the future

        :param command: String. commands to run. Individual commands should be separated by semicolon(;)
        :param MACHINES: List. Private IPs to run on. If none is passed the command will be run against all nodes
        :param Container: Bool. Flag to run the commands inside the object-main container of each node
        :param do_LogMessage: Bool. Ignore log level and log a message
        :param no_LogMessage: Bool. Ignore log level and do not log anything
        :param print_Verbose: Bool. Flag to print additional output
        :param noErrorHandling: Bool. Do not try to process any errors if one is encountered
        :return: Dict. self.run_cmd results, with the MACHINE (IP address) as a keys
        """
        OutputList = dict()

        if not MACHINES:
            MACHINES = self.machines

        for MACHINE in MACHINES:
            output = self.run_cmd(command, MACHINE=MACHINE, container=Container, do_LogMessage=do_LogMessage,
                                  no_LogMessage=no_LogMessage, print_Verbose=print_Verbose,
                                  noErrorHandling=noErrorHandling)
            # ContainerOption=""
            # if Container:
            #     ContainerOption="-c "
            # viprcmd='viprexec '+ContainerOption+'-n '+MACHINE+' \''+command+'\''
            #
            # output=self.run_cmd(viprcmd, do_LogMessage=False, no_LogMessage=False, print_Verbose=print_Verbose)
            #
            # output['stdout']=output['stdout'].replace("\nOutput from host : "+MACHINE+" \n",'')
            # output['stdout']=output['stdout'].replace("Output from host",'')

            OutputList[MACHINE] = output

        return OutputList

    def handle_cmd_error(self, cmd_output, showWarnings=True, NoExit=False):
        command = cmd_output['command']
        retval = cmd_output['retval']
        stdout = cmd_output['stdout']
        stderr = cmd_output['stderr']

        if retval != 0:  # Non-zero return code, command was not successful

            # XXX - use err_output?

            self.msg_output("ERROR: While executing command '{}'".format(command), error=True, newline=True)

            if retval == 124:
                self.msg_output("Error 124: Command timed out", newline=True, error=True)
            else:
                self.msg_output("Return code was: {}".format(retval), error=True, newline=True)

            if isinstance(stdout, basestring) and stdout != "":
                self.msg_output("Command output:", error=True, newline=True)
                self.msg_output(stdout, error=True, newline=True)
            else:
                self.msg_output("No output returned", error=True, newline=True)

            if isinstance(stderr, basestring) and stderr != "":
                self.msg_output("Error text returned:", error=True, newline=True)
                self.msg_output(stderr, error=True, newline=True)
            else:
                self.msg_output("No error text returned.", error=True, newline=True)

            if not NoExit:
                # At this point, exit due to an unrecoverable error - user will need to correct something before
                # continuing
                self.msg_output("EXITING...", error=True, newline=True)

                exit(1)  # XXX - Should it be an error related to the calling command's return code?
        elif isinstance(stderr, basestring) and stderr != "" and showWarnings:
            # Command completed but error output was returned
            # XXX - Should I assume it's a warning?  Or look for the "WARNING" keyword in output?  Or...
            self.msg_output("Warning:  While executing command '{}'".format(command), error=True, newline=True)
            self.msg_output("Output generated: \n{}".format(stderr), error=True, newline=True)

            # XXX - Should we pause to ask if they want to continue at this point?

    def msg_output(self, text="", req_loglevel=0, indent=0, newline=True, do_LogMessage=False, no_LogMessage=False,
                   print_Text=True, error=False):
        """
        Output runtime text either to the screen, a logfile, or both. All verbose output always goes to debug logfile

        :param text: Message to be printed
        :type text: str
        :param req_loglevel: Level of message required to actually output to screen
        :type req_loglevel: int
        :param indent: Number of 4 space indents to prepend to the message
        :type indent: int
        :param newline: Append newline character to text
        :type newline: bool
        :param do_LogMessage: Ignore log level and log a message
        :type do_LogMessage: bool
        :param no_LogMessage: Ignore log level and do not log a message
        :type no_LogMessage: bool
        :param print_Text: Whether to print the message for the user
        :type print_Text: bool
        :param error: Change how printed message is formatted for error messages
        :type error: bool
        :return: String that was passed with requested formatting applied
        """
        padding = indent * '    '  # 4 spaces per indent
        text = padding + ('\n' + padding).join(text.split('\n'))  # add indentation to incoming string

        if newline:
            text += "\n"

        if print_Text:  # Print text to the screen
            if req_loglevel <= self.verbose:  # loglevel of this message is low enough to print to the screen
                if error:
                    text = '{}{}{}'.format(self.colors.FAIL, text, self.colors.ENDC)

                sys.stdout.write(text)
                sys.stdout.flush()  # Otherwise output may not be sent immediately

        return text

    def check_dt_ready(self):
        """
        GET stats/dt/DTInitStat

        Checks the DT init status for the system and prints the result on success. If DT's are unknown or unready
        it will wait and then recheck them. If it still fails it will log the error and exit the script

        :return: none
        """
        dt_req_timeout = 15 * 60  # Time to wait (in seconds) for a DT request to return.
        # Assume if we haven't heard back in this amount of time
        # that the request is hung, not just slow.
        dt_total_timeout = dt_req_timeout * 2  # Time to wait total for DTs to come ready; 30 minutes in this case.
        # Ensure that we make at least 2 DT requests before we fail. If we're getting dtquery responses
        # and DTs just aren't ready, will make more than 2 passes

        retry_delay = 15  # delay until next retry
        dtready = False

        # Get IP that dtquery is listening on (tcp port 9101) on local node
        self.msg_output("Checking DT initialization status (please wait)...", newline=False)

        # Run the dtquery

        self.msg_output("\nWaiting up to " + str(dt_total_timeout / 60) + " minutes for DTs to come ready",
                        req_loglevel=1)

        dtquery_results = dict.fromkeys(["total_dt_num", "unready_dt_num", "unknown_dt_num"], None)
        dtquery_start = int(time())
        firstpass = True

        dt_listen_IP = None

        while int(time()) < (dtquery_start + dt_total_timeout):  # Retry to see if DTs come ready

            # Get the IP we're listening for dtquery info on, if needed
            if dt_listen_IP is None:
                dt_listen_IP = self.get_listen_ip(9101, service_name="dtquery service")

            if dt_listen_IP is None:
                sleep(retry_delay)
                continue

            if firstpass:
                tempstring = "Requesting"
                firstpass = False
            else:
                tempstring = "Re-requesting"

            self.msg_output(
                tempstring + " dt query status.  Waiting up to " + str(dt_req_timeout) + " seconds for a reply",
                req_loglevel=1)

            cmd = "curl -m " + str(
                dt_req_timeout) + " -sS http://" + dt_listen_IP + ":9101/stats/dt/DTInitStat | xmllint --format - | grep -A4 '<entry>'"
            result = self.run_cmd(cmd)

            # Should return something like:
            #   <entry>
            #     <total_dt_num>2048</total_dt_num>
            #     <unready_dt_num>0</unready_dt_num>
            #     <unknown_dt_num>0</unknown_dt_num>
            #   </entry>
            #
            # ... although if there are problems, may be a number of sets of these results with details
            # about different DT types; occasionally multiple entries are returned.  We'll look only at
            # the first "unready" and "unknown" results if there are multiples

            # XXX - would it make sense to just use an XML parser?

            # Produce warning messages for certain conditions:

            if "Failed" in result['stdout']:
                self.msg_output("\nWARNING: Unexpected output from dt query.  Check upgrade log for more details")

            # Parse results

            dtlines = result['stdout'].strip().splitlines()

            for line in dtlines:
                if "<total_dt_num>" in line and "</total_dt_num>" in line:
                    dtquery_results['total_dt_num'] = line.split("<total_dt_num>")[1].split("</total_dt_num>")[0]
                if "<unready_dt_num>" in line and "</unready_dt_num>" in line:
                    dtquery_results['unready_dt_num'] = line.split("<unready_dt_num>")[1].split("</unready_dt_num>")[0]
                if "<unknown_dt_num>" in line and "</unknown_dt_num>" in line:
                    dtquery_results['unknown_dt_num'] = line.split("<unknown_dt_num>")[1].split("</unknown_dt_num>")[0]

            self.msg_output("  total_dt_num: " + str(dtquery_results['total_dt_num']) + " unready_dt_num: " + str(
                dtquery_results['unready_dt_num']) + " unknown_dt_num: " + str(dtquery_results['unknown_dt_num']),
                            req_loglevel=2)

            if str(dtquery_results['unready_dt_num']).strip() == "0" and str(
                    dtquery_results['unknown_dt_num']).strip() == "0":
                dtready = True
                break  # Things look good, exit loop and don't retry

            sleep(retry_delay)

        if not dt_listen_IP:
            self.print_failed()
            self.msg_output("ERROR:  Could not determine IP address listener for dtquery (port 9101).", error=True)
            self.msg_output("  Either dtquery is not running on this node, or an unexpected condition", error=True)
            self.msg_output("  was encountered.", error=True)
            exit(15)

        if not dtready:
            self.print_failed()
            self.msg_output("ERROR: check_dt_ready(): One or more DTs were unready or unknown, or had", error=True)
            self.msg_output("an unexpected value.", error=True)
            self.msg_output("  total_dt_num:   {}".format(dtquery_results['total_dt_num']), error=True)
            self.msg_output("  unready_dt_num: {}".format(dtquery_results['unready_dt_num']), error=True)
            self.msg_output("  unknown_dt_num: {}".format(dtquery_results['unknown_dt_num']), error=True)
            exit(16)
        else:
            self.print_done()
            self.msg_output("  total_dt_num: " + str(dtquery_results['total_dt_num']) + " unready_dt_num: " + str(
                dtquery_results['unready_dt_num']) + " unknown_dt_num: " + str(dtquery_results['unknown_dt_num']))

    def get_listen_ip(self, port, service_name=None, noErrorHandling=False, viprexec=False, quiet=False):
        """
        Given a port, return the IP adress that is currently listening on it

        :param port: The port to check for what IP is listening on it
        :type port: int/str
        :param service_name: The name of the service you are checking
        :type service_name: str
        :param noErrorHandling: Passed on to run_cmd. Ignore any errors returned by bash when checking netstat
        :type noErrorHandling: bool
        :param viprexec: Whether to get the listening IP for just the local machine or for every node
        :type viprexec: bool
        :param quiet: Suppress printing
        :type quiet: bool
        :return: IP address listening on a given port. If running with viprexec, retutn dict of listen IPs using node
                    numbers as keys
        :rtype: str / dict
        """
        msg = "Getting listener IP for port {}".format(port)
        if service_name:
            msg = '{} [{}]'.format(msg, service_name)
        logging.info(msg)
        if not quiet:
            self.msg_output(msg, req_loglevel=1, indent=1)

        # test for 2.2 localhost style
        localhost = False
        any_ip = False

        ips = []

        if not viprexec:
            cmd = "netstat -an | grep :{} | grep LISTEN".format(port)
            result = self.run_cmd(cmd, do_sudo=True, noErrorHandling=noErrorHandling)

            for line in result['stdout'].splitlines():
                ips.extend(self.extract_ip(line))

            public_ip = [x for x in ips if x not in ['127.0.0.1', '0.0.0.0']]
            if public_ip:
                logging.info('Found {} listening on Port {}'.format(public_ip[0], port))
                return public_ip

            for ip in ips:
                if ip == '127.0.0.1':
                    localhost = True
                elif ip == '0.0.0.0':
                    any_ip = True

            if any_ip:
                logging.info('Found {} listening on Port {}'.format(self.get_node('current')['public'], port))
                return self.get_node('current')['public']
            elif localhost:
                logging.info('Found {} listening on Port {}'.format('localhost', port))
                return 'localhost'
            else:
                logging.error('Did not find any IPs listening on {}'.format(port))
                return None

        else:
            result = {}
            cmd = "{} netstat -an | grep :{} | grep LISTEN".format(self.get_sudoicmd(), port)
            resp = self.viprexec(cmd)

            for node in resp:
                for line in resp[node]:
                    ips = self.extract_ip(line)
                    public_ip = [x for x in ips if x not in ['127.0.0.1', '0.0.0.0']]
                    if public_ip:
                        logging.info('Node {} - Found {} listening on Port {}'.format(node, public_ip[0], port))
                        result[node] = public_ip[0]
                        localhost = False
                        any_ip = False
                        break

                    if '127.0.0.1' in ips:
                        localhost = True
                    elif '0.0.0.0' in ips:
                        any_ip = True

                if result.get(node):
                    pass
                elif any_ip:
                    logging.info('Node {} - Found {} listening on Port {}'.format(
                        node,
                        self.rack_info[node]['public'],
                        port)
                    )
                    result[node] = self.rack_info[node]['public']
                elif localhost:
                    logging.info('Node {} - Found {} listening on Port {}'.format(node, 'localhost', port))
                    result[node] = 'localhost'
                else:
                    logging.error('Node {} - Did not find any IPs listening on {}'.format(node, port))
                    result[node] = None
            return result

    def copy_to_nodes(self, file_name, targetdir, tmpdir="/var/tmp", MACHINE=None, skipcurrent=False, container=False):
        """
        Copy a file to one or all nodes. If a MACHINE IP has been specified, copy only to that node. By default files
        are copied to all nodes. If copying to all nodes, optionally skip the current node.

        :param file_name: Path to file to be copied (absolute or relative)
        :param targetdir: Absolute path to target directory
        :param tmpdir: Optional. Path to temporary directory for copy. File is then moved to targetdir
        :param MACHINE: private IP of a node. If passed, file will only be copied to that node
        :param skipcurrent: Bool. Skip the node you are running the script from when doing copy
        :param container: Bool. if passed the file wille be copied to the object-main container on that node(s)
        """
        if not MACHINE:
            machines = self.machines
        else:
            machines = [MACHINE]

        basefile = os.path.basename(file_name)

        # Check if source file exists

        if not os.path.isfile(file_name):
            self.msg_output("ERROR: copy_to_nodes(): Source file '{}' not found or is not a file.".format(file_name),
                            error=True)
            exit(6)

        # get md5sum of file
        for node in machines:

            # Check if destination dir exists on each node before copying to any

            result = self.run_cmd('[[ -d {} ]] && echo dir found'.format(targetdir), MACHINE=node,
                                  container=container)

            if not result['stdout'].strip() == "dir found":
                self.msg_output("ERROR: copy_to_nodes(): Target directory '{}' not found or is not".format(targetdir),
                                error=True)
                self.msg_output("  a directory.", error=True)
                if container:
                    self.msg_output("Target:  '{}:object-main:{}'".format(MACHINE, targetdir), error=True)
                else:
                    self.msg_output("Target:  '{}:{}'".format(MACHINE, targetdir), error=True)

                exit(7)

        if container:
            for node in machines:
                # Check if tmpdir exists

                result = self.run_cmd('[[ -d {} ]] && echo dir found'.format(tmpdir), MACHINE=node, container=False)
                if not result['stdout'].strip() == "dir found":
                    self.msg_output(
                        "ERROR:  copy_to_nodes(): Directory '{}' not found or is not a directory.".format(tmpdir),
                        error=True, newline=True)

        for node in machines:
            # Copy the file to nodes
            if not container:
                DestDir = targetdir
            else:
                DestDir = tmpdir

            result = self.run_cmd("viprscp -n {} {} {}/{}".format(node, file_name, DestDir, basefile))

            # Check md5sum

            if container:
                # Move to final destination
                self.run_cmd("docker cp {}/{} object-main:{}/{}".format(DestDir, basefile, targetdir, basefile),
                             MACHINE=node)

                # Remove original
                self.run_cmd("rm -f " + DestDir + "/" + basefile, MACHINE=node, no_LogMessage=True)

    def print_done(self):
        self.msg_output('{}DONE{}'.format(self.colors.OK, self.colors.ENDC))

    def print_failed(self):
        self.msg_output('{}FAILED{}'.format(self.colors.FAIL, self.colors.ENDC))

    def post_cmd_output(self, output, failed=False, error_text=None, indent=0, delay=0):
        # When we run various tasks, we want to display to the screen/log in format:
        #   "Running some operation...DONE"
        #   "  <verbose text, if applicable>"
        # or
        #   "Running some operation...FAILED"
        #   "  <verbose text, if applicable>"
        #   "  <error text>"
        #
        # We frequently won't know whether the operation has completed or failed until after
        # we've run the command and processed the results.
        #
        # In these cases, we need to postpone printing out any verbose info or error output
        # until after printing "DONE" or "FAILED" - so can't do it inside self.run_cmd().
        #
        # This function takes the output of self.run_cmd, and depending on "Failed" flag,
        # prints out a colorized "DONE" or "FAILED", followed by any error text
        # and verbose info.

        # Remember string potentially already comes in indented

        if not failed:
            self.print_done()
        else:
            self.print_failed()
            sleep(delay)  # If specified, delay between printing "failed" and printing the
            # (potentially very verbose) error message.  Usability thing to
            # give the user a chance to register that an error happened before
            # flooding the screen with output

        # self.msg_output("=================== Verbose output =====================", req_loglevel=1, indent=indent)
        if str(output['verbose_out'].strip()):
            self.msg_output(output['verbose_out'], req_loglevel=1, indent=indent)
        if str(output['veryverbose_out'].strip()):
            self.msg_output(output['veryverbose_out'], req_loglevel=2, indent=indent)

        if failed:
            self.msg_output("=================== Fatal Error =====================", indent=indent, error=True)
            self.msg_output("Return value: {}".format(output['retval']), indent=indent, error=True)
            self.msg_output(output['error_out'], indent=indent, error=True)
            self.msg_output("=====================================================", indent=indent, error=True,
                            newline=True)
            self.msg_output(error_text, indent=indent, error=True)

    @staticmethod
    def encapsulate_shell_cmd(cmd, sudo=False):
        """
        Inserts escape characters for commands that are going to be run by run_cmd()

        :param cmd: the command that needs to be encapsulated
        :type cmd: str
        :param sudo: Flag to add sudo -i to the passed command
        :type sudo: bool
        :return: formatted command for running
        :rtype: str
        """
        cmd = cmd.replace("'", "'\\''")
        if sudo:
            cmd = 'sudo -i LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 {}'.format(cmd)

        return cmd

    @staticmethod
    def extract_ip(search_string):
        """
        Will extract all IPs from a passed string using re module and return them

        :param search_string: The string to search for IPs
        :type search_string: str
        :return: List of found IPs. Will return empty list if no IPs are found
        :rtype: list
        """
        return re.findall(r"(?:[0-9]{1,3}\.){3}[0-9]{1,3}", search_string)

    @staticmethod
    def get_sudoicmd():
        """
        By default when running "sudo -i", warnings are returned to stderr because there's no default value for the
        LC_ALL and LANG environment variables.

        :return: string that allows sudo -i to be run
        :rtype: str
        """
        # XXX - need to make sure we're getting the correct values instead of this hardcode hack

        lc_all = "en_US.UTF-8"
        lang = "en_US.UTF-8"

        sudoicmd = "sudo -i LANG={} LC_ALL={} ".format(lang, lc_all)

        return sudoicmd

    @staticmethod
    def get_interface_ip(ifname):
        """
        Determine the IP based on interface name

        :param ifname: name of the interface to get IP for
        :type ifname: str
        :return: IP of the interface passed
        :rtype: str
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return socket.inet_ntoa(fcntl.ioctl(sock.fileno(), 0x8915, struct.pack('256s', ifname[:15]))[20:24])

    @staticmethod
    def which(program):
        """
        Helper function that uses unix tool 'which' to determine if program is on the system

        :param program: name of the program to get version/location of
        :type program: str
        """
        status, _ = commands.getstatusoutput("which %s" % program)
        return status == 0

    def read_hosts_file(self, fname):
        """
        Create a list of host_names or ip's from the file. The file should have one and only one hostname or ip per line

        :param fname: name of the file to check for hosts
        :type fname: str
        :return: list of host IPs
        :rtype: list
        """
        hosts_lst = []
        try:
            file_p = open(fname, 'r')
        except (IOError, os.error), msg:
            print msg
        else:
            for line in file_p:
                line = line.strip()
                if line.startswith("#") or line == "":
                    continue
                else:
                    hosts_lst.append(line)

        return hosts_lst

    def remove_me(self, hosts):
        """
        Filters out by private/public IP and hostname
        :param hosts: List of hosts
        :return: list of filtered host IPs
        """
        filter_list = list(socket.gethostname())
        filter_list.append(self.get_interface_ip("private"))
        filter_list.append(self.get_interface_ip("public"))
        return [item for item in hosts if item not in filter_list]

    def create_machines_file(self):
        """
        Creates a MACHINES file using getrackinfo -c
        """
        if not os.path.isfile(self.machines_file_name):
            cmd = "/usr/sbin/getrackinfo -c {}".format(self.machines_file_name)
            status, _ = commands.getstatusoutput(cmd)
            if status == 0:
                print "Did not find a %s file so I made one with createrackinfo" \
                      % self.machines_file_name
                print "Created the file: %s" % self.machines_file_name
                print commands.getoutput("cat %s" % self.machines_file_name)

    @staticmethod
    def is_vm():
        """
        Determines if the script is being run on a VM

        :return: True or False
        :rtype: bool
        """
        cmd = "dmidecode | grep -q 'VMware Virtual Platform'"
        status, _ = commands.getstatusoutput(cmd)
        return status == 0

    def build_host_list(self, options):
        """
        Function to generate the list of hosts to operate on
        """
        hosts = []
        if self.is_vm():
            def_file = "/opt/storageos/conf/data_nodes"
        else:
            def_file = self.machines_file_name

        if options.filename:
            hosts = self.read_hosts_file(options.filename)
        elif options.hosts:
            hosts = options.hosts.split(',')
        elif os.path.isfile(def_file):
            hosts = self.read_hosts_file(def_file)

        if not hosts:
            self.create_machines_file()
            hosts = self.read_hosts_file(self.machines_file_name)

        if options.notme:
            hosts = self.remove_me(hosts)

        return hosts

    def viprexec(self, cmd, hosts='', container_name=''):
        """
        Run a command with viprexec and parse the return to an extent. Be careful of running certain API calls such as
        chunk dumps as they will return massive amounts of data

        :param cmd: The command to be run
        :type cmd: str
        :param hosts: Comma separated list of nodes to run on. Default behavior is all nodes
        :type hosts: str
        :param container_name: name of the container to run against. Acceptable values are:
                object-main
                fabric-lifecycle
                fabric-zookeeper
                fabric-registry
                fabric-syslog
                filebeat
        :type container_name: str
        :return: Dictionary of the response from viprexec, using the node numbers as keys. The response for each node
                 will be a list of the lines, generated using the .splitlines() builtin string method
        :rtype: dict
        """
        vipr_response = {}
        cmd = 'viprexec \'{}\''.format(self.encapsulate_shell_cmd(cmd))

        if container_name:
            cmd = '{} -c --dock={}'.format(cmd, container_name)

        if hosts:
            cmd = '{} --hosts={}'.format(cmd, hosts)

        resp = self.run_cmd(cmd, print_Verbose=False)
        for line in resp['stdout'].splitlines():
            # Skip blank lines
            if not line:
                continue
            elif 'Output from host' in line:
                private_ip = self.extract_ip(line)[0]
                node = [self.rack_info[x]['id']
                        for x in self.rack_info
                        if self.rack_info[x]['private'] == private_ip][0]
                vipr_response[node] = []
            else:
                vipr_response[node].append(line)

        return vipr_response


class BColors:
    """
    Defines ANSI colors for colorized output in terminal
    """

    # XXX - can I check that the terminal is capable first?  Is there a better way (curses, etc)?
    def __init__(self):
        self.HEADER = '\033[95m'
        self.OK = '\033[92m'
        self.WARNING = '\033[93m'
        self.FAIL = '\033[91m'
        self.ENDC = '\033[0m'
        self.BOLD = '\033[1m'
