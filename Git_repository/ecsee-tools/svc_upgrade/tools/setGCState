#!/usr/bin/python

# Copyright (c) 2016 EMC Corporation
# All Rights Reserved
#
# This software contains the intellectual property of EMC Corporation
# or is licensed to EMC Corporation from third parties.  Use of this
# software and the intellectual property contained therein is expressly
# limited to the terms and conditions of the License Agreement under which
# it is provided by or on behalf of EMC.

import os
import subprocess
import getopt
import sys
import os.path
from subprocess import Popen, PIPE

CurScriptName=os.path.basename(__file__)
CurPathName=os.path.dirname(__file__)

Version="1.3"


mode=""
showcurrent=True
user=None
password="ChangeMe"
verbose=False
repoflag=True
btreeflag=True

cf_client=CurPathName+"/cf_client"

curVal=dict()
paramsList=dict()
paramsList['repo']=[
	"com.emc.ecs.chunk.gc.repo.enabled",
	"com.emc.ecs.chunk.gc.repo.verification.enabled"]
paramsList['btree']=[
	"com.emc.ecs.chunk.gc.btree.scanner.verification.enabled",
	"com.emc.ecs.chunk.gc.btree.scanner.copy.enabled",
	"com.emc.ecs.chunk.gc.btree.enabled"]



def usage():

	global CurScriptName

	print "Usage: "+CurScriptName+" [options]"
	print "Version "+Version
	print
	print "Enables/disables GC activity"
	print
	print "options:"
	print "-h, --help        Show this help message and exit"
	print "-c, --check       Check whether service is enabled or disabled"
	print "-e, --enable      Enable service"
	print "-d, --disable     Disable service"
	print
	print "-b, --btree       (Optional) Only enable/disable btree GC"
	print "-r, --repo        (Optional) Only enable/disable repo GC"
	print
	print "-u, --user        (Optional) valid admin username"
	print "-p, --password    (Optional) valid admin password"

	exit(1)

def parse_args(argv):

	global mode,user,password,showcurrent,verbose,repoflag,btreeflag

	allowedArgs=dict()
	allowedArgs['short']="hcedbrvu:p:n"
	allowedArgs['long']=["help","check","enable","disable","btree","repo","verbose","user=","password=","nocurrent" ]

	try:
		opts, args = getopt.getopt(argv,allowedArgs['short'],allowedArgs['long'])
	except getopt.GetoptError:
		usage()

	for opt, arg in opts:
		if opt in ("-h", "--help"):
			usage()
		elif opt in ("-c", "--check"):
			mode=""
		elif opt in ("-e", "--enable"):
			mode="true"
		elif opt in ("-d", "--disable"):
			mode="false"
		elif opt in ("-u", "--user"):
			user=arg
		elif opt in ("-b", "--btree"):
			repoflag=False
		elif opt in ("-r", "--repo"):
			btreeflag=False
		elif opt in ("-n", "--nocurrent"):
			showcurrent=False # Do not display the current state
		elif opt in ("-p", "--password"):
			password=arg
		elif opt in ("-v", "--verbose"):
			verbose=True
		else:
			usage()


def encapsulate_shell_cmd(cmd):
	return(cmd.replace("'", "'\\''"))

def err_output(text=""):
	sys.stderr.write(text)
	sys.stderr.flush() # Otherwise output may not be sent immediately


def getCurUser():

	# Determine which username should be used and confirm it (and the current password)
	# can be used to run cf_client.

	if user != None:
		# If the user has manually provided a username, test that.
		userlist=[user]
	else:
		# Otherwise, need to detect the user.

		# Based on the current application version, we need to use either emcmonitor (2.x) or
		# emcservice (3.x) user.

		# There's a few ways we could handle checking which we should use, but we'll just test
		# whether the emcservice user exists.  If so, use it.  If not, use emcmonitor.

		# So try both, with emcservice first.  Return the first one that works.

		userlist=["emcservice", "emcmonitor"]


	for username in userlist:
		testcmd=cf_client+' --user '+str(username)+' --password '+str(password)+' --status'

		output=run_cmd(testcmd)

		# If successful, we should get back a list of statuses in json format, with retval 0.
		# Output should contain the string "generation" as one of the keys.

		# If unsuccessful "normally", retval should be 1 and
		# we should get back a message like "Failed to login user, status: 1, code: 401".
		# Currently handle all failures the same.

		if output['retval'] == 0 and "generation" in output['stdout']:
			return username

	# If we've gotten that far, then cf_client tests have failed.

	err_output("ERROR: Could not perform cf_client queries.")
	err_output()
	err_output("Attempts to run cf_client using username '"+username+"' and")
	err_output("  password '"+password+"' failed.  ")
	err_output()
	err_output("This may mean that the user or password are incorrect.  A valid admin")
	err_output("  user account is required.")
	err_output()
	err_output("This may also mean that fabric services are not fully functioning.")
	err_output()
	err_output("Command run: '"+testcmd+"'")
	err_output("Output was:")
	err_output(str(output['stdout']))
	err_output(str(output['stderr']))

	exit(5)



def run_cmd(command, Container=False):

	if Container:
		command="sudo docker exec object-main sh -c '"+encapsulate_shell_cmd(command)+"'"

	p = Popen(command, shell=True, stdout=PIPE, stderr=PIPE, bufsize=1)
	stdout=""
	stderr=""

	stdout, stderr = p.communicate()
	retval = p.returncode

	VerboseOutput="Command was: \n"
	VerboseOutput+=command+"\n"
	VerboseOutput+="\n"
	VerboseOutput+="stdout was:\n"
	VerboseOutput+=stdout.strip()+"\n"
	VerboseOutput+="\n"
	VerboseOutput+="stderr was:\n"
	VerboseOutput+=stderr.strip()+"\n"

	cmd_output = {'command':command,
				 'stdout':stdout,
	             'stderr':stderr,
				 'retval':retval,
				 'verbose':VerboseOutput}


	return cmd_output


def setParam(param, value, reason):
	result=run_cmd(cf_client+' --user '+user+' --password '+password+' --set --name '+param+' --value "'+value+'" --reason "'+reason+'"')
	if verbose:
		print result['verbose']
	return result


def checkParam(param):
	result=run_cmd(cf_client+' --user '+user+' --password '+password+' --list --name '+param+' | grep configured_value | awk \'{ print $2 }\'')

	if result['stdout'].strip()=="":
		# Must still be the default value
		result=run_cmd(cf_client+' --user '+user+' --password '+password+' --list --name '+param+' | grep default_value | awk \'{ print $2 }\'')
		return result['stdout'].strip()
	else:
		return result['stdout'].strip()



def checkVals():

	global paramsList,curVal

	for type,val in paramsList.iteritems():
		curList=paramsList[type]

		for param in curList:
			curVal[param]=checkParam(param)
			print "Value of '"+param+"': "+curVal[param]




def SetParams(value, repoflag, btreeflag):

	global paramsList

	if repoflag:
		for param in paramsList['repo']:
			setParam(param, value, "prevent STORAGE-15711 before patching the fix")
	if btreeflag:
		for param in paramsList['btree']:
			setParam(param, value, "prevent STORAGE-15711 before patching the fix")



############## Main logic ##############

parse_args(sys.argv[1:])

user=getCurUser()

if verbose==True:
	print "Current user is: "+user

if showcurrent:
	print "Current vals:"
	checkVals()

if mode!="":
	print "Setting 'enabled' to "+mode+" for params"
	SetParams(mode, repoflag, btreeflag)

	print "Vals after change:"
	checkVals()

	# Validate that vals after change are as expected

	valerr=False
	for param,value in curVal.iteritems():
		if (btreeflag and "btree" in param) or (repoflag and "repo" in param):
			if not mode in value:
				print "ERROR:  Value for '"+param+"' should be '"+mode+"'"
				valerr=True

	if valerr:
		exit(1)
