#!/usr/bin/python

# Copyright (c) 2016 EMC Corporation
# All Rights Reserved
#
# This software contains the intellectual property of EMC Corporation
# or is licensed to EMC Corporation from third parties.  Use of this
# software and the intellectual property contained therein is expressly
# limited to the terms and conditions of the License Agreement under which
# it is provided by or on behalf of EMC.

import os
import subprocess
import getopt
import sys
import time
import inspect
import pprint

CurScriptName=os.path.basename(__file__)
CurPathName=os.path.dirname(__file__)

sys.path.append(CurPathName+"/lib")

#import state
import svc_upgrade_common as common
from svc_upgrade_common import *  # Declare functions/objects in local namespace

all_totaltime=0
common.Global_LogMessage=True



def usage():

	global CurScriptName

	print "Usage: "+CurScriptName+" [options]"
	print "Version "+common.Version
	print
	print "options:"
	print "-h, --help        Show this help message and exit"
	print

	# Display different usage messages depending on "level" usage is needed at:
	# - Top-level usage (no upgrade type sepcified)
	# - Usage for OS upgrade
	# - Usage for Application upgrade

	# Top-level options:

	if common.upgradeType is None:

		print "-O, --OS          ECS OS upgrade"
		print "-A, --application ECS Application Software upgrade"
		print
		print "  For additional usage info, run an option above with -h"
		exit (1)

	# OS upgrade options:
	if common.upgradeType is "OS":

		print "ECS OS Upgrade tasks (specify one or more):"
		print "-a, --all          Execute all upgrade-related activities"
		print "-r, --precheck     Perform pre-upgrade health checks"
		print "-d, --deploy       Deploy and prepare os upgrade software"
		print "-o, --os           Perform OS update and reboot nodes"
		print "-t, --postcheck    Perform post-upgrade health checks"
		print
		print "Other options:"
		print "-v, --verbose      Enable verbose output"
		print "-V, --veryverbose  Enable very verbose output"
		print "-N, --noscreen     Do not attempt to run inside a screen session"
		print "-s, --skipcheck    Comma-separated list of pre- or post-upgrade"
		print "                   health checks to skip"
		print
		print "OS upgrade options:"
		print "-x, --version      Target code version (e.g. 3.0, 3.0HF1)"
		print "-n, --node <#>     Perform OS install and reboot on this node only"
		print "-m, --mode <online|offline>    Perform online or offline upgrade"
		print "                   (required)"

		exit (1)

	# Application upgrade options:

	if common.upgradeType is "Application":

		print "ECS Application Upgrade tasks (specify one or more):"
		print "-a, --all          Execute all upgrade-related activities"
		print "-r, --precheck     Perform pre-upgrade health checks"
		print "-d, --deploy       Deploy and prepare object/fabric software"
		#print "-o, --ospatch     Perform OS quickfit update"
		print "-l, --hal          Upgrade HAL"
		print "-f, --fabric       Upgrade fabric and object services"
		print "-t, --postcheck    Perform post-upgrade health checks"
		print
		print "Other options:"
		print "-u, --username     GUI admin user (default is 'root')"
		print "-p, --password     GUI admin password (default is 'ChangeMe')"
		print
		print "-v, --verbose      Enable verbose output"
		print "-V, --veryverbose  Enable very verbose output"
		print "-N, --noscreen     Do not attempt to run inside a screen session"
		print "-s, --skipcheck    Comma-separated list of pre- or post-upgrade"
		print "                   health checks to skip"
		print
		print "HAL and fabric upgrades options:"
		print "-x, --version      Target code version (e.g. 3.0, 3.0HF1)"
		print "-m, --mode <online|offline>    Perform online or offline upgrade"
		print "                   (required for fabric)"
		print "-T, --topology <file>  Topology file name and location"
		print "                   (required)"
		print "-E, --extend <file>  Extension file name and location"
		print "                   (optional)"
		print "-P, --provision <file>  Provisioning file name and location"
		print "                   (default is: <installer dir>/conf/provisioning.txt)"
		print "-Z, --appfile <file> application.conf file name and location"
		print "                   (optional)"
		print "-S, --sku <sku>    System SKU (e.g. U300)"
		print "                   (default is auto-detect)"

		exit (1)

def parse_args(argv):

	result=parse_global_args(argv, req_version=True, req_upgradeType=True)

	if result is "usage":
		usage()

	# Check to make sure at least SOME task was specified, required to do anything

	try:
		opts, args = getopt.getopt(argv,common.allowedArgs['short'],common.allowedArgs['long'])
	except getopt.GetoptError:
		print ("Unknown option supplied")
		return("usage")


	for opt, arg in opts:
		if opt in ("-e", "--resume"):
			do_resume()
			break

	TaskSpecified=False
	for taskname,val in common.UpgradeTasks.viewitems():
		if val['Enabled'] is True:
			TaskSpecified=True

	if TaskSpecified is False:
		print "ERROR: No task to run was specified"
		print ""
		usage()

def do_resume():

	result=read_state_file()

	if result==None: # No result file existed
		err_output("No upgrade session to resume")
		exit(101)

	msg_output( "Resuming previous upgrade.")
	msg_output( "")
	msg_output( "Upgrade Type:         "+str(common.upgradeType))
	msg_output( "Upgrade Mode:         "+str(common.upgradeMode))
	msg_output( "Last completed Task:  "+str(common.lastCompletedTask))
	msg_output( "Next task:            "+str(getNextTask()))
	msg_output()
	msg_output( "SKU:                  "+str(common.sku))
	msg_output( "Topology file:        "+str(common.topologyfile))
	msg_output( "Extend file:          "+str(common.extendfile))
	msg_output( "Provision file:       "+str(common.provisionfile))
	'''msg_output( ": "+common.)
	msg_output( ": "+common.)'''
	msg_output()
	msg_output("Continue?")

	response=""
	while True:
		#response=raw_input("Type \"READY\" <enter> to continue: ")
		response=raw_input("Please enter Y or N to continue: ")
		if response.strip().lower() == "y":
			break
		if response.strip().lower() == "n":
			msg_output("Exiting...")
			exit(1)




def getNextTask():
	# Really want to reorganize how the task info is stored, and where

	NextTask=None

	if common.lastCompletedTask==None:
		HitTask=True # Start looking for the first enabled task
	else:
		HitTask=False # Start looking for the last completed task

	for taskname, details in common.UpgradeTasks.viewitems():
		if HitTask==False and taskname==common.lastCompletedTask:
			# We've found the last task.  Set a flag so we start looking for the next to run
			HitTask=True
			continue

		if HitTask==True and details['Enabled']==True: # Found the next task
			NextTask=taskname
			break

	return NextTask


def run_task_cmd(taskdetails, args):

	global all_totaltime
	# Need to figure out how we're handling execution and errors here

	description=taskdetails['Description']

	msg_output("================= "+description+" =================")

	starttime=time()  # For task profiling

	cmd=taskdetails['FileName']+args

	result=run_cmd(cmd, noErrorHandling=True, realtime=True, no_LogMessage=True)

	stoptime=time()
	totaltime=stoptime-starttime
	all_totaltime+=totaltime

	msg_output("\n"+description+" total time: "+str(totaltime)+"s", req_loglevel=0)

	stderr=result['stderr']
	stdout=result['stdout']
	retval=result['retval']

	"""print result['stdout']
	if isinstance(stderr, basestring) and stderr != "":
		sys.stderr.write(stderr)
	"""

	if result['retval'] is 200 or result['retval'] is 201:
		err_output("\nNeed to connect to different node.  Exiting.")
		cleanup (result['retval'])
	if result['retval'] is not 0 and result['retval'] is not 200 and result['retval'] is not 201:
		err_output("\nERROR:  "+description+" failed.")
		if "ErrorText" in taskdetails:
			err_output("\n"+taskdetails['ErrorText'])
		cleanup (result['retval'])

def cleanup(exitval):
	msg_output("\nDetailed output logged to: "+common.logfile, no_LogMessage=True)
	exit (exitval)

############## Main logic ##############


parse_args(sys.argv[1:])

# Check if running inside a screen session. If not, start an instance of this script inside one.


if "STY" not in os.environ:  # If the "$STY" environment variable is defined, we're in a screen session

	# Not currently inside a screen session.  Re-execute this script inside one.

	if common.screen:
		# Create a string with arguments that were passed to this invocation of the script,
		# so we can pass to the in-screen invocation.
		screen_argstring="--noscreen " # Avoid unintentionally creating a recursive loop
		screen_argstring+=" ".join(sys.argv[1:])
		msg_output ("Starting upgrade inside a screen session", req_loglevel=1)

		cmd="screen ./"+CurScriptName+" "+screen_argstring
		result=run_cmd(cmd)

		exit(result['retval'])
else:
	screen_session=os.environ['STY']

common.argString=common.argString+" --log "+common.logfile


msg_output()
msg_output("===============================================")
msg_output("====== Start new upgrade session v"+Version+" ======")
msg_output("==============================================")
msg_output()

if screen_session is not None:
	msg_output("Note:  This upgrade is running inside a 'screen' session.  If")
	msg_output("you are disconnected, the upgrade will continue to run.")
	msg_output("To reconnect to your running upgrade session in the future, run")
	msg_output("  screen -r "+screen_session)
	msg_output()


# UpgradeTasks is an OrderedDict that defines whether we're configured to
# run a particular task, and details about (like the filename, the description
# we'll print to screen, etc.

# As we loop through and complete tasks, we set the "lastCompletedTask" state var.
# This info will be saved to disk to allow resuming.

# Determine if we should run the task by checking the next task to run (based on
# what tasks are enabled to run, and which was last to run).

for taskname, details in common.UpgradeTasks.viewitems():
	if taskname=="all":
		continue

	if taskname==getNextTask():
		#cmd=details['FileName']+common.argString
		run_task_cmd(details, common.argString)

		common.lastCompletedTask=taskname # Mark the task as completed
		write_state_file() # Save current state to disk


msg_output("\nAll tasks total time: "+str(all_totaltime))

cleanup(0)

# XXX - should we check whether another upgrade session is in progress and abort?
