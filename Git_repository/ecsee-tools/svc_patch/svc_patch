#!/bin/bash

################################################################
#
# NAME
# 	svc_patch
#
# SYNOPSIS
#	svc_patch [-dt] [<filename>] <source> <target> {email address} {processes to restart or ALL}
#
# VERSION
VERSION="2.5.2"
#
# DESCRIPTION
#       apply_patch for ECS with no python dependancy for DIY (and appliance)
#	-dt option will check DT's before it moves to next node. 
#
################################################################

# 2.5.2 - If unknown patches/changes are installed, script will still make a "best guess"
#         on which patches are installed
# 2.5.1 - Fixed bug leading to all services being restarted instead of only one service
#         in some cases
# 2.5.0 - Added extended dependency checking and cumulative patch installs.
#         Added option for listing what patches are currently installed
#         Prompts user to install any missing files
#         Added option for forcing reinstall of all patches in the current branch
# 2.1.5 - Fix for restarting "ALL" services in 2.2.1.*
# 2.1.4 - Added support for dependency checking on both dare and non-dare systems
# 2.1.3 - Fixed bug that causes copy to fail if a previous patch attempt was made as
#         a different user (particularly root)
#         Fixed bug with DTQueries not being validated at the correct point
#         Fixed bug causing help not to display properly
#         Validate patch bundle consistency with included MD5SUMS file in the bundle
# 2.1.2 - renamed from apply_patche to svc_patch
#         Added initial dependency checking logic
#         Modified method of copying files to container to improve speed 30%
#         Added extended (user-modifiable) pause between node service restarts

#set -e

DEBUG=0
ECHO="/bin/echo -e"

# Default paths
#LOG_DIR="/opt/emc/caspian/fabric/agent/services/object/main/log"
#PATCH_LOG="/opt/storageos/logs/patches.log"
#DEBUG_LOG="/opt/storageos/logs/patches-debug.log"
PERM_DIR="/opt/emc/caspian/patches" # Dir we'll distribute a copy of the svc_script to once patch install completes.
LOG_DIR="$PERM_DIR/log"
PATCH_LOG="$LOG_DIR/patches.log"
DEBUG_LOG="$LOG_DIR/patches-debug.log"
SCRIPTNAME="$(basename $0)"
SCRIPTDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" # parent directory of script
			  # And directory containing the rest of the patch bundle being installed, if any
CONTAINER_LOG_DIR="/opt/storageos/logs"

# Default timings
MAX_DELAY=600 # Maximum configurable time in seconds to wait between service restarts
SVC_TIMEOUT=180 # Maximum time in seconds to wait for a service to restart
MAX_DT_CHECK=4 # Maximum # of times to wait for DTs to come ready before aborting
MAX_DT_WAIT=360 # Maximum amount of time to wait for a DT query to complete
SERVICE_DELAY=2 # Time to wait after each service has restarted to move on to the next (same node)
NODE_DELAY=120 # Time to wait after services on a node have restarted to move on to next node

TSTAMP=`date +%Y-%m-%d_%H.%M.%S` # Used for marking the patch backup time

OKColor='\033[92m'
FAILColor='\033[91m'
SKIPColor='\033[93m'
GREYColor='\033[0,37m'
ENDColor='\033[0m'
JQ="./jq" # Utility for parsing json data
re='^[0-9]+$' # Regular expression for validating value is an integer

declare -A PatchDef # Store properties of each patch in the patch chain, loaded from  .def file
declare -A MasterDef # Store master properties for the patch set, including list of patches in the patch chain

# Associative arrays containing lists of patch names, filenames, and services.
# Each key of the array is a node name (by IP address).
# Each element of the array is a list of values separated by spaces (so bash tokenized into list of values)
# Note this doesn't support values with spaces in them - if we ever support filenames with spaces will need to change this to comma-delimited, etc

declare -A installed_patches
declare -A patches_to_install
declare -A files_to_install
declare -A files_to_install_version
declare -A files_to_install_destdir
declare -A services_to_restart
declare -A Patch_MD5SUMS
#declare -A cur_md5sums



SUPPORTED_SERVICES=( stat cm rm dtquery authsvc georeceiver eventsvc blobsvc \
	objheadsvc provisionsvc resourcesvc ssm objcontrolsvc metering storageserver \
	hdfssvc filesvc cassvc vnest coordinatorsvc dataheadsvc ecsportalsvc transformsvc \
	ALL )

ORIG_IFS=$IFS


function usage
{
  $ECHO "Usage:  $SCRIPTNAME <MACHINES file>"
  $ECHO "           | [-installed]"
  $ECHO "           | [-p <patch def file]"
  $ECHO "           | [-f <filename> -d <directory to install file> -service <service,...>]"
  $ECHO "           | [-dt] [-debug] [-h] [-email <address>] [-delay <# sec>]"
  $ECHO "           | [-timeout <# sec>] [-dttimeout <# sec>]"
  $ECHO ""
  $ECHO "Options:"
  $ECHO "\t-h: Help         - This help screen"
  $ECHO
  $ECHO "\t-installed:      - List installed patches and exit"
  $ECHO
  $ECHO "\t-debug: Debug    - Produces additional debugging output"
  $ECHO "\t-email:          - Email address of person installing patch"
  $ECHO "\t-delay:          - Additional delay to wait between service restarts on each node"
  $ECHO "\t                   (default: $NODE_DELAY)"
  $ECHO "\t-timeout:        - Maxumum time to wait for a service to restart before"
  $ECHO "\t                   aborting (default: $SVC_TIMEOUT)"
  $ECHO "\t-dt:             - Perform DT status queries and wait for all DTs to come"
  $ECHO "\t                   ready before applying patch to each node."
  $ECHO "\t-dttimeout:      - Maxumum time to wait for a dt query to complete before"
  $ECHO "\t                   aborting and retrying (default: $MAX_DT_WAIT)"
  $ECHO ""
  $ECHO "\t-p: patch def    - Read the patch details from a patch definition file."
  $ECHO "\t                   (default: main.def)"
  $ECHO ""
  $ECHO "Single file install options (incompatible with -p option, all required):"
  $ECHO "\t-f: Filename     - File to install on nodes (e.g. storageos-stat.jar)"
  $ECHO "\t-d: Directory    - Directory in container to install file to"
  $ECHO "\t-service:        - Comma-separated list of services to restart"

  exit 1

}

function parse_args
{

	MANUALMODE=0
	FORCE_INSTALL=0
	SHOWINSTALLED=0
	DTCHECK="false"

	if [[ $# -lt 1 ]]; then
		usage
	fi

	MACHINES="$1"
	shift 1

	if [[ "$MACHINES" == "-h" ]]; then
		usage
	fi

	if [[ ! -f "$MACHINES" ]]; then
		echo "ERROR:  Machines file '$MACHINES' not found.  Exiting."
		echo ""
		exit 1
	fi

	parse_MACHINES "$MACHINES"


	while [ -n "$1" ]
	do
		case $1 in
		"" )
			;;
        "-debug" )
            DEBUG=1
            #set -x
            shift 1
            ;;
        "-h" )
            usage
            ;;
        "-installed" )
            SHOWINSTALLED=1
			shift 1
            ;;
		#"-f" )
		#	PATCH_FILES[0]="$2"
		#	if [[ "${PATCH_FILES[0]}" == "" ]]; then
		#		echo "ERROR:  No patch filename supplied with -f option.  Exiting."
		#		exit 1
		#	fi

		#	if [[ ! -f "${PATCH_FILES[0]}" ]]; then
		#		echo "ERROR:  Filename (${PATCH_FILES[0]}) not found.  Exiting."
		#		exit 1
		#	fi

		#	if [[ ! -r "${PATCH_FILES[0]}" ]]; then
		#		echo "ERROR:  Filename (${PATCH_FILES[0]}) not readable.  Exiting."
		#		exit 1
		#	fi

		#	MD5SUMS[0]="$(md5sum "${PATCH_FILES[0]}" | awk '{ print $1 }')"

		#	if [[ "${MD5SUMS[0]}" == "" ]]; then
		#		echo "ERROR: Could not calculate md5sum for file (${PATCH_FILES[0]}).  Exiting."
		#		exit 1
		#	fi

		#	MANUALMODE=1
		#	shift 2
		#	;;
		"-d" )
			DESTDIRS[0]="$2"
			if [[ "${DESTDIRS[0]}" == "" ]]; then
				echo "ERROR: No destination directory supplied with -d option.  Exiting."
				exit 1
			fi

			MANUALMODE=1
			shift 2
			;;
		"-email" )
			EMAIL_ADDRESS="$2"
			if [[ "$EMAIL_ADDRESS" == "" ]]; then
				echo "ERROR: No email address specified with -email option.  Exiting."
				exit 1
			fi

			if [[ ! "$EMAIL_ADDRESS" == *"@"* ]]; then
				echo "ERROR: Email address specified (${EMAIL_ADDRESS}) does not appear to be a valid email address.  Exiting."
				echo ""
				exit 1
			fi


			shift 2
			;;
		"-delay" )
			NODE_DELAY="$2"
			if [[ "$NODE_DELAY" == "" ]]; then
				echo "ERROR: No value specified with -delay option.  Exiting."
				exit 1
			fi

			if [[ ! "$NODE_DELAY" =~ $re ]]; then
				echo "ERROR: Time specified for -delay is not a number.  Exiting."
				exit 1
			fi

			if [[ $NODE_DELAY -lt 0 || $NODE_DELAY -gt $MAX_DELAY ]]; then
				echo "ERROR: Time specified for -delay is outside the allowed range (0-${MAX_DELAY}).  Exiting."
				exit 1
			fi

			shift 2
			;;
		"-timeout" )
			SVC_TIMEOUT="$2"
			if [[ "$SVC_TIMEOUT" == "" ]]; then
				echo "ERROR: No value specified with -timeout option.  Exiting."
				exit 1
			fi

			if [[ ! "$SVC_TIMEOUT" =~ $re ]]; then
				echo "ERROR: Time specified for -timeout is not a number.  Exiting."
				exit 1
			fi

			if [[ $SVC_TIMEOUT -lt 0 || $SVC_TIMEOUT -gt 9999 ]]; then
				echo "ERROR: Time specified for -timeout is outside the allowed range (0-9999).  Exiting."
				exit 1
			fi

			shift 2
			;;
		"-dttimeout" )
			MAX_DT_WAIT="$2"
			if [[ "$MAX_DT_WAIT" == "" ]]; then
				echo "ERROR: No value specified with -dttimeout option.  Exiting."
				exit 1
			fi

			if [[ ! "$MAX_DT_WAIT" =~ $re ]]; then
				echo "ERROR: Time specified for -dttimeout is not a number.  Exiting."
				exit 1
			fi

			if [[ $MAX_DT_WAIT -lt 0 || $MAX_DT_WAIT -gt 9999 ]]; then
				echo "ERROR: Time specified for -dttimeout is outside the allowed range (0-9999).  Exiting."
				exit 1
			fi

			shift 2
			;;
		"-dt" )
			DTCHECK="true"
			shift 1
			;;
		#"-service" )
		#	SERVICES="$2"
		#	if [[ "$SERVICES" == "" ]]; then
		#		echo "ERROR: No value(s) specified with -service option.  Exiting."
		#		echo ""
		#		exit 1
		#	fi

		#	MANUALMODE=1
		#	shift 2
		#	;;
		"-force_install" )
			FORCE_INSTALL=1
			shift 1
			;;

        *)
			echo "ERROR:  Invalid option '${1}'"
			echo ""
            usage
            ;;
		esac
	done # Loop through parameters


	# Post processing after all arguments have been parsed

	if [[ $MANUALMODE -eq 1 ]]; then # XXX - remove manual mode
		if [[ "${PATCH_FILES[0]}" == "" ]]; then
			echo "ERROR:  Manual patch installation, and no filename specified.  Exiting."
			echo ""
			usage
		fi

		if [[ "${DESTDIRS[0]}" == "" ]]; then
			echo "ERROR:  Manual patch installation, and no destination directory specified.  Exiting."
			echo ""
			usage
		fi
	fi


}

function escapequotes {
	# Returns string that has had single-quotes shell-escaped
	IFS="\n"

	string="$@"


	for line in "$string"; do
		echo -e "${line}\n" | sed "s/'/'\\\''/g" | sed 's/"/\\"/g'
	done

	IFS=$OLD_IFS
}


function print_message {
	# Prints a message to the screen and to the log

	local _DEBUG="$1"
	shift 1

	local _MESSAGE="$*"

	$ECHO "$_MESSAGE"

	log_message $_DEBUG "$_MESSAGE"

}

function isBaseRelease {

	local _patchName="$1"

	if [[ "$_patchName" == "${MasterDef[BaseRelease]}" ]]; then
		echo "1"
	else
		echo "0"
	fi

}

function make_patch_dirs {

	# Check for and, if needed, create the directories that will be used to store
	# patch installer files and logs

	# svc_patch copies itself (and all supoport files, like *.def files) to this dir
	# Log files are stored to the /logs dir inside this dir

	if [[ ! -d "$LOG_DIR" ]]; then
		if [[ -e "$LOG_DIR" ]]; then
			echo "ERROR:  Log pathname ($LOG_DIR) exists, but is not a directory.  Exiting."
			exit 10
		fi

		sudo mkdir -m 777 -p "$LOG_DIR"

		retval=$?

		if [[ $retval -ne 0 ]]; then
			echo "ERROR:  Attempting to create the log directory or its parent dirs failed.  Exiting."
			echo "  Directory attempted to create:  '$LOG_DIR'"
			exit 11
		fi

		if [[ ! -d "$LOG_DIR" ]]; then
			echo "ERROR:  Log pathname ($LOG_DIR) does not exist after attempting to create.  Exiting."
			exit 12
		fi
	fi

	sudo chmod 777 "$PERM_DIR"
	sudo chmod 777 "$LOG_DIR"

}

function log_message {

	# Logs a message in the patch log in the object-main container on a
	# given node

	#local _NODE="$1"
	local _DEBUG="$1"
	shift 1

	local _MESSAGE="$*"
	curDate="$(date +"%Y-%m-%d %H.%M.%S")"

	# Build list of logs to update - for debug messages, log only
	# to the debug log.
	# For regular messages, log to both logs.

	if [[ $_DEBUG -eq 1 ]]; then
		local _LOGS=("$DEBUG_LOG")
	else
		local _LOGS=("$PATCH_LOG" "$DEBUG_LOG")
	fi


	if [[ "$EMAIL_ADDRESS" != "" ]]; then
		local _fullMessage="${curDate}: (${EMAIL_ADDRESS}) $(escapequotes "${_MESSAGE}")"
	else
		local _fullMessage="${curDate}: $(escapequotes "${_MESSAGE}")"
	fi

	testmessage="${_fullMessage}"



	for _LOG in $_LOGS; do

		#ssh $NODE sudo docker exec object-main "bash -c \"echo -e '$_fullMessage' >> '$_LOG'\""
		sudo bash -c "echo -e '$_fullMessage' >> '$_LOG'"

		# execute_container_cmd $_NODE "echo '$_fullMessage' >> '$_LOG'"

	done

}

function log_debug_message {

	# Shortcut/clearer function for loging debug-only messages

	#local _NODE="$1"
	#shift 1

	local _MESSAGE="$*"

	#log_message "$_NODE" 1 "$_MESSAGE"
	log_message 1 "$_MESSAGE"

}

function debug_print {

	local _MESSAGE="$*"

	if [[ $DEBUG -eq 1 ]]; then
		echo -e "\t$_MESSAGE"
	fi

	log_debug_message "$_MESSAGE"

}

function validate_services {

	# Validate services specified are allowed

	for key in "${!SERVICES_ARRAY[@]}"
	do
		MATCHED=0
		SERVICE=${SERVICES_ARRAY[$key]}

		for otherkey in "${!SUPPORTED_SERVICES[@]}"
		do
			CHECK_SERVICE=${SUPPORTED_SERVICES[$otherkey]}

			if [[ "$SERVICE" == "$CHECK_SERVICE" ]]; then
				MATCHED=1
				break
			fi
		done

		if [[ $MATCHED -eq 0 ]]; then
			echo "ERROR:  Service to restart specified (${SERVICE}) is not supported."
			exit 1
		fi
	done

}

function parse_MACHINES {

	MACHINESFile="$1"

	if [[ ! -r "$MACHINESFile" ]]; then
		echo "ERROR: Could not read MACHINES file ('${MACHINESFile}').  Exiting"
		exit 1
	fi

	NODES=( "$( cat "$MACHINESFile" | grep "^[0-9]" )" ) # Only lines starting with numbers
	NUMNODES=0

	if [[ ${#NODES[@]} -lt 1 ]]; then
		echo "ERROR:  No IP addresses found in MACHINES file."
		exit 1
	fi

	for NODE in $NODES; do
		if [[ ! "$NODE" == *'.'*'.'*'.'* ]]; then # Verify each entry looks like an IP address
			echo "ERROR:  Entry in MACHINES file is not a valid IP"
			echo -e "\tEntry was: ${NODE}"
			exit 1
		fi
		if [[ $DEBUG -eq 1 ]]; then
			echo "Node read from MACHINES: $NODE"
		fi
		(( NUMNODES+=1 ))
	done


}

function add_to_list {
	# XXX - add description

	local __resultvar=$1
	local _value="$2"

	local _SpaceVal=""
	if [[ "$__resultvar" != "" ]]; then
		_SpaceVal=" "
	fi

	eval $__resultvar="${_SpaceVal}${_value}"

}

function parse_md5sum {
	# Parse text containing md5sum output and store in an associative array.
	# Filenames are array keys, values are the md5sum.

	# First argument is the variable to store in.
	# Second argument is a quoted set of md5sums separated by lines and spaces.

	# For example, parse_md5sum result "318b4388205d89923a6435be870c5017 file1\n661bfca3a7d821333fa8c5a3a4675957 file2" would result in:
	# $result[file1]="318b4388205d89923a6435be870c5017"
	# $result[file2]="661bfca3a7d821333fa8c5a3a4675957"

	local  __resultvar=$1
	local md5sumtext="$2"
	unset temp_md5sums; declare -A temp_md5sums


	while read -r line; do
		i=0
		temparray=()
		for field in $line; do
			temparray[${i}]="$field"
			(( i+=1 ))
		done

		temp_md5sums[${temparray[1]}]="${temparray[0]}"
	done <<< "$md5sumtext"

	# Assign to passed variable name (stored in $__resultvar)
	for key in "${!temp_md5sums[@]}"; do
		eval $__resultvar["$key"]="${temp_md5sums["$key"]}"
	done

	#eval $__resultvar="'$temp_md5sums'"

}


function check_dare {
	# Determine whether the current node appears to be running a dare or nondare release.

	debug_print "Checking if DARE is enabled"

	cmd="rpm -q storageos-dare 2>&1"

	darecheck=$(execute_container_cmd "$NODE" "$cmd" 0)
	# Expects back output like:
	#  storageos-dare-3.0.0.0.85807.98632a9-1.x86_64 (if dare enabled)
	#  package storageos-dare is not installed (if dare not enabled)

	if [[ "$darecheck" == *"storageos-dare-"*".x86_64" ]]; then
		DAREENABLED=1
	elif [[ "$darecheck" == *"is not installed" ]]; then
		DAREENABLED=0
	else
		echo "ERROR: Could not determine whether dare was enabled or disabled."
		echo ""
		echo "Attempted to run '${cmd}' inside the container on node $NODE"
		echo "Output was:"
		echo "$darecheck"
		exit 3
	fi

	if [[ $DAREENABLED -eq 1 ]]; then
		debug_print "DARE is enabled\n"
	else
		debug_print "DARE is not enabled\n"
	fi


}

function check_installed_patches {

	debug_print "Checking for installed patches"

	dependencycheck_failed=0
	sanitycheck_failed=0
	filenotfound=0

	# Split patch list into array


	# Check each node

	for NODE in $NODES; do

		debug_print "\tChecking patches on node '$NODE'"

		unset _node_md5sums; declare -A _node_md5sums  # declare/reset reset temp array used for this loop only
		unset _found_md5sums; declare -A _found_md5sums

		# Get md5sums for each file in the important dirs.  This contains the majority of files we'll potentially be patching, and we can get with a single call.
		# Should return output like
		# 957e2adab0814216138504b6dcc553b9  /opt/storageos/bin/zkutils
		# 357b51589581fe79c123985534a261fa  /opt/storageos/lib/FPLibrary-3.3.62.jar
		output=$(execute_container_cmd "$NODE" "md5sum /opt/storageos/bin/* /opt/storageos/lib/* /opt/storageos/conf/* /etc/cron.hourly/* 2>/dev/null" 0)

		# Parse into an array we'll use for comparison later
		parse_md5sum _node_md5sums "$output"


		# Loop through each patch's md5sum file, checking whether the files for it are installed.
		# If a file is found, mark it as found in an array - we don't need to check for it again in earlier patches
		# If all of the files in the current patch are found, mark the patch as installed in a global array

		for patch_name in ${MasterDef[PatchList]}; do

			# Check each of the files in the patch to see if they match what is on-system or have already been found while checking an earlier patch.
			# If one is found, mark it as found in $_found_md5sums so we skip it while checking earlier patches (i.e. it's the latest version of the file in the patch chain, so the version we should install)

			patch_installed=1  # If a file is found missing while in the loop, this flag will be flipped

			debug_print "\t\tChecking files for patch '$patch_name' on node $NODE"
			# XXX - need error handling if file is blank or we otherwise found no files

			#for filen in ${!_patch_md5sums[@]}; do

			#unset _patch_md5sums; declare -A _patch_md5sums
			#get_patch_md5sums "$patch_name" # sets $_patch_md5sums

			#unset _patch_md5sums; declare -A _patch_md5sums # declare/reset temp array used for this loop only
			#if [[ $(isBaseRelease "$patch_name") -eq 1 && $DAREENABLED -eq 0 ]]; then # if we're parsing the master patch and DARE is disabled
			#	md5sum_filename="$SCRIPTDIR/md5sums/${patch_name}.MD5SUMS.nondare"
			#else
			#	md5sum_filename="$SCRIPTDIR/md5sums/${patch_name}.MD5SUMS"
			#fi


			#output="$(cat "$md5sum_filename")"
			#parse_md5sum _patch_md5sums "$output"

			#for _filename in ${!_patch_md5sums[@]}; do
			local _files="$(get_patch_property "$patch_name" "Files")"
			local _filename

			for _filename in $_files; do

				local _md5sum="${Patch_MD5SUMS[${patch_name}-${_filename}]}"

				# Skip if a newer version of the file from a newer patch was already found
				if [[ "${_found_md5sums[$_filename]}" == "found" ]]; then
					continue
				fi

				# Check if the file on the system matches the file in the patch

				# If we didn't already cache an on-node md5sum for the file, try again to get that specific file

				if [[ "${_node_md5sums[$_filename]}" == "" ]]; then
					debug_print "\t\t\tOn-node md5sum not found for file '$_filename' on node '$NODE', trying to get md5sum"

					new_md5sum=$(execute_container_cmd "$NODE" "md5sum $_filename 2>/dev/null | awk '{ print \$1 }'" 0)
					if [[ "$new_md5sum" == "" ]]; then
						filenotfound=1
						filenotfound_error+="Node ${NODE}:  $_filename  not found or could not determine md5sum\n"
					else
						_node_md5sums[$_filename]="$new_md5sum"
					fi

				fi


				#debug_print "\t\t\tComparing patch md5sum ($_md5sum) to node md5sum (${_node_md5sums[$_filename]}) for file '$_filename'"
				if [[ "${_node_md5sums[$_filename]}" == "$_md5sum" ]]; then
					_found_md5sums[$_filename]="found"
				else
					debug_print "\t\t\tmd5sum not matched while checking '$_filename' for patch '$patch_name' on node '$NODE'.  Installed md5sum: ${_node_md5sums[$_filename]}  patch md5sum: $_md5sum"
					_found_md5sums[$_filename]="not found"
					patch_installed=0
				fi
			done

			if [[ $patch_installed -eq 1 ]]; then
				installed_patches[$NODE]="${installed_patches[$NODE]} $patch_name"
				#add_to_list installed_patches[$NODE] "$patch_name"
			fi
		done

		# Check if there were any files that were marked as "not found" even after checking the whole patch tree (which should include MD5SUMS for the GA release, so all potential
		# versions of the file).

		# If so, then there are unknown patches or other changes installed.  Set a flag that will abort the script and add to a message that will be printed.

		# However, do not throw an error if the file wasn't included in the definition for the base release.  This means we're not sure what the "default" version of a file is,
		# and the patch includes a file that we didn't include in the base definition.  Can happen if a patch includes an obscure (but valid) file.

		for filename in ${!_found_md5sums[@]}; do
			if [[ "${_found_md5sums[$filename]}" == "not found" ]]; then
				# Check to see if this file was defined in the base definition file; if not, we consider this file to not require validation; we're only checking the file to determine installed patches.
				if [[ "${Patch_MD5SUMS[${MasterDef[BaseRelease]}-${filename}]}" != "" ]]; then
					dependencycheck_failed=1
					dependency_error+="$(printf "%-23s%-50s%-30s" "Node ${NODE}:" "$filename " "${_node_md5sums[$filename]}")\n"
					#"Node ${NODE}:  $filename  ${_node_md5sums[$filename]}\n"
				else
					# As a sanity check, check to make sure that at least one well-known file is in the base release md5sum list.
					# This helps protect against cases where an error has led to no entries being read, which can cause validation to be essentially skipped silently.

					if [[ "$filename" == "/opt/storageos/lib/storageos-blobsvc.jar" ]]; then
						sanitycheck_failed=1
					fi

				fi
			fi
		done

	done

	if [[ ${#_found_md5sums[@]} -lt 1 ]]; then
		sanitycheck_failed=1
	fi

	debug_print ""

	if [[ $sanitycheck_failed -eq 1 ]]; then
		sanitycheck_error+="ERROR: Did not read any md5sum entries for the base release.\n"
		sanitycheck_error+="\n"
		sanitycheck_error+="To validate the currently installed patches and look for potential (dangerous) conflicts, md5sum of core files\n"
		sanitycheck_error+="is expected to be parsed from an md5sum file.\n"
		sanitycheck_error+="\n"
		sanitycheck_error+="A critical entry was missing, indicating a problem parsing the file or performing checks\n"
		sanitycheck_error+="\n"
		sanitycheck_error+="This is an unexpected error - exiting\n"
		return 4
	fi


	if [[ $filenotfound -eq 1 ]]; then
		return 3
	fi

	if [[ $dependencycheck_failed -eq 1 ]]; then
		#echo -e "$dependency_error"
		return 2
	fi



}

function get_patches_to_install {

	# Based on the patches that aren't installed, get the names of files that need to be installed
	# If the user has specified re-installing all patches, then return all patches in the patch list.

	# Sets "patches_to_install" variable

	local _resorted_patchlist

	if [[ ${MasterDef[PatchList]} == "" ]]; then
		echo "ERROR: get_patches_to_install():  Patch list is empty.  Unexpected error, Exiting."
		exit 1
	fi

	# create a list of patches that's from oldest to newest
	for patch in ${MasterDef[PatchList]}; do
		_resorted_patchlist="$patch $_resorted_patchlist"
	done

	# Find oldest uninstalled patch on each node. - mark that patch and all newer patches
	# as needing to be installed

	for NODE in $NODES; do

		missing_patch=0
		for patch in $_resorted_patchlist; do
			if [[ $missing_patch -eq 1 ]]; then # If we've already found a missing patch, add all newer ones to the list
				patches_to_install[$NODE]="${patches_to_install[$NODE]} $patch"
				#add_to_list patches_to_install "$patch"
				continue
			fi


			found=0
			for installed_patch in ${installed_patches[$NODE]}; do # Scan the installed patch list to compare
				if [[ "$patch" == "$installed_patch" ]]; then
					found=1
				fi
			done

			if [[ $found -eq 0 ]]; then # Patch in the patch list isn't installed
				missing_patch=1
				patches_to_install[$NODE]="${patches_to_install[$NODE]} $patch"
				#add_to_list patches_to_install "$patch"
				continue
			fi
		done

	done # Loop through nodes



}


function get_install_files {

	# Based on the patches that need to be installed, get the names of files that need to be copied

	# Sets $files_to_install   # name of file to install, including full path
	# Sets $files_to_install_version  # Patch to pull the file from (needed if different patches have changes to the same file, we need to know what version to use)

	local _patch

	for NODE in $NODES; do

		for _patch in ${patches_to_install[$NODE]}; do

			#files="$(get_patch_property "$patch" "Files")"
			# Loop through each, add to the list of files to install if it doesn't already exist in the list

			#for file in $files; do
			#unset cur_md5sums; declare -A cur_md5sums
			#get_patch_md5sums "$_patch" # sets $cur_md5sums

			unset _patch_md5sums; declare -A _patch_md5sums # declare/reset temp array used for this loop only

			#output="$(cat "$SCRIPTDIR/md5sums/${_patch}.MD5SUMS")"
			#parse_md5sum cur_md5sums "$output"


			#for file in ${!cur_md5sums[@]}; do
			#echo "getting files list for patch $_patch"
			local _files="$(get_patch_property "$_patch" "Files")"
			local _filename

			for _filename in $_files; do

				#echo -e "checking file $_filename"
				#file="${cur_md5sums[$key]}"
				#filename=$(basename $file)
				#destdir=$(dirname $file)

				found_file=0
				# Check to see if it's already in the list
				for existingfile in ${files_to_install[$NODE]}; do
					if [[ "$existingfile" == "$_filename" ]]; then # already in the list
						files_to_install_version[${NODE}_${_filename}]="$_patch" # Update the version of file to install to the newest patch found so far
						found_file=1
					fi
				done

				if [[ $found_file -eq 0 ]]; then
					files_to_install[$NODE]+=" $_filename"
					files_to_install_version[${NODE}_${_filename}]="$_patch"
				fi
			done
		done # Loop through each patch to install
	done # Loop through each node


}


function get_restart_services {

	# Based on the patches that need to be installed, determine the services that need to be restarted

	# Sets $services_to_restart

	for NODE in $NODES; do

		services_to_restart[$NODE]=""

		for patch in ${patches_to_install[$NODE]}; do
			services="$(get_patch_property "$patch" "Services")"

			# Loop through each, add to the list of services to restart if it doesn't already exist in the list
			# Ignore "None" and if any have "ALL" set, replace the entire list with just "ALL" and return

			for service in $services; do
				if [[ "$service" == "None" ]]; then
					continue
				fi

				if [[ "$service" == "ALL" || "${services_to_restart[$NODE]}" == "ALL" ]]; then
					services_to_restart[$NODE]="ALL"
					continue
				fi


				found_service=0
				# Check to see if it's already in the list
				for tempservice in ${services_to_restart[$NODE]}; do
					if [[ "$tempservice" == "$service" ]]; then
						found_service=1
					fi
				done

				if [[ $found_service -eq 0 ]]; then
					services_to_restart[$NODE]+=" $service"
				fi
			done

		done # Loop through each patch
	done # Loop through nodes

	if [[ ${#services_to_restart[@]} -eq 0 ]]; then # List is empty
		services_to_restart[$NODE]="None"
	fi
}

function get_pre_scripts {

	# Sets $pre_scripts

	for NODE in $NODES; do

		for patch in ${patches_to_install[$NODE]}; do
			PreScript="$(get_patch_property "$patch" "PreScript")"

			if [[ "$PreScript" != "" && "$PreScript" != "null" ]]; then
				pre_scripts[$NODE]+=" $PreScript"
			fi

		done # Loop through each patch
	done # Loop through nodes
}

function get_post_scripts {

	# Sets $post_scripts

	for NODE in $NODES; do

		for patch in ${patches_to_install[$NODE]}; do
			PostScript="$(get_patch_property "$patch" "PostScript")"

			if [[ "$PostScript" != "" && "$PostScript" != "null" ]]; then
				post_scripts[$NODE]+=" $PostScript"
			fi

		done # Loop through each patch
	done # Loop through nodes
}



function get_patch_property {

	# Returns a value from a patch definition that's been read in.

	# Because:
	#   - bash doesn't support arrays of arrays
	#   - each patch property (like patch name, description, list of services, etc) is stored in an associative array
	#   - each patch has a different name, and we want to be able to access properties of a patch based on name
	# ...Then patch details are stored in specially-named array values.

	# For example, customer name info for patch STORAGE-12345 will be stored as:
	#   PatchDef['STORAGE-12345-CustomerName']="JPMC"
	# ...Where the array key contains two parts - the patch name and the property name.

	# Based on passed patch name and property name, return the value (if any)

	local _PatchName="$1"
	local _PropertyName="$2"

	#echo "${_PatchName}-${_PropertyName}"
	#echo "${PatchDef[${_PatchName}-${_PropertyName}]}"

	value="${PatchDef[${_PatchName}-${_PropertyName}]}"
	echo "$value"
}

#function get_patch_md5sums {

	# Sets a temp array with all the md5sums for a patch read from a patch file

#	local _PatchName="$1"
#	local _debug="$2"

#	local _filename=""
#	local _md5sum=""

#	for key in ${!patch_md5sums[@]}; do
		# $key will be something like STRG-123456_CustomerName-3.0_/opt/storageos/lib/storageos-stat.jar
		#    or Patchname_Filename
#		if [[ $_debug -eq 1 ]]; then
#			echo "checking if '$key' starts with '${_PatchName}_'"
#		fi
#		if [[ "$key" == "${_PatchName}_"* ]]; then
#			if [[ $_debug -eq 1 ]]; then
#				echo "it does"
#			fi

#			_filename="$(echo $key | sed -e "s/^${_PatchName}_//")"
#			_md5sum=${patch_md5sums[$key]}
#			if [[ $_debug -eq 1 ]]; then
#				echo "assigning '$_md5sum' to cur_md5sums[${_filename}]"
#			fi
#			cur_md5sums[$_filename]="$_md5sum"
#		fi
#	done

#}


function parse_master_def_file {

	# Read various properties from the patch master definition file, including:
	#   - A space-separated list of patches in the patch (used for checking what patches are installed, which patches
	#     potentially need to be installed, etc)
	#   - The name of the release (e.g. ECS-3.0-GA - used to determine which object in the patch list is
	#     the "root", there's some special processing when validating those files
	#   - The "main" patch (again, minor special processing)


	masterDefFile="$1"

	debug_print "Reading Master definition file '${masterDefFile}'"
	debug_print ""

	if [[ "$masterDefFile" == "" ]]; then
		echo "ERROR:  parse_master_def_file():  No master definition filename specified.  Exiting"
		exit 1
	fi

	if [[ ! -f "$masterDefFile" ]]; then
		echo "ERROR:  parse_master_def_file(): Master definition filename (${masterDefFile}) does not exist.  Exiting."
		exit 1
	fi

	# Retrieve values

	#MasterDef[PrimaryPatch]="$(cat ${masterDefFile} | $JQ '.PrimaryPatch' -r)" # e.g. "STORAGE-12345"
	MasterDef[PatchList]="$(cat ${masterDefFile} | $JQ '.PatchList' -r)" # e.g. "STORAGE-12345 STORAGE-23456 ECS-3.0-GA"
	MasterDef[BaseRelease]="$(cat ${masterDefFile} | $JQ '.ReleaseName' -r)" # e.g. "ECS-3.0-GA"
	MasterDef[StandalonePatch]="$(cat ${masterDefFile} | $JQ '.StandalonePatch' -r)" # Whether this patch potentially contains earlier patches or has no cumulative patch support.  Should be "true" or "false"


	# Verify each value was read and wasn't blank (mandatory)

	for key in ${!MasterDef[@]}; do
		val=${MasterDef[$key]}
		if [[ "$val" == "" || "$val" == "null" ]]; then
			echo "ERROR: Required field '$key' could not be read from master def file '$masterDefFile', or field blank.  Exiting."
			exit 1
		fi
	done

	# Validate the PrimaryPatch and BaseRelease are same (should be first and last values in the PatchList)
	# XXX - do we actually need those values, or can we just extract from the PatchList?

	#if [[ "${MasterDef[PatchList]}" != "${MasterDef[PrimaryPatch]} "* ]]; then  # Check that PrimaryPatch shows up at the beginning of the patch list
	#	echo "ERROR:  parse_master_def_file(): PrimaryPatch (${MasterDef[PrimaryPatch]}) appears invalid.  Is not the first entry in the PatchList.  Exiting."
	#	exit 1
	#fi
	if [[ "${MasterDef[PatchList]}" != *" ${MasterDef[BaseRelease]}" ]]; then  # Check that BaseRelease shows up at the end of the patch list
		echo "ERROR:  parse_master_def_file(): BaseRelease (${MasterDef[BaseRelease]}) appears invalid.  Is not the last entry in the PatchList.  Exiting."
		exit 1
	fi


	# Validate the expected metadata files for the patches are present, and read in patch details.
	#   Should be a file for each entry in the patch list in /md5sums directory
	#   Should be a file for each patch (everything in the patch list except the "BaseRelease") in /patch_defs directory

	for patchname in ${MasterDef[PatchList]}; do
		# Check for an MD5SUMS file

		if [[ ${MasterDef[StandalonePatch]} != "false" || $FORCE_INSTALL -eq 1 ]]; then

			if [[ $(isBaseRelease "${patchname}") -eq 1 ]]; then
				continue # Don't look for md5sums file for the base release if force installing or standalone patch
			fi
		fi

		MD5SUMS_FileName="${SCRIPTDIR}/md5sums/${patchname}.MD5SUMS"
		if [[ ! -f "${MD5SUMS_FileName}" ]]; then
			echo "ERROR: MD5SUMS file '$MD5SUMS_FileName' does not exist or is not a file.  Exiting."
			exit 1
		fi

		# Check for definition files, read into arrays

		#if [[ "$patchname" != "${MasterDef[BaseRelease]}" ]]; then # Skip if this is the current Release, where we're only checking md5sums, there is no def file
			parse_patch_details "$patchname"  # Stores values in $PatchDef
			retval=$?

			if [[ $retval -ne 0 ]]; then
				echo "$output"
				exit $retval
			fi
		#fi
	done


	if [[ "${MasterDef[StandalonePatch]}" != "true" && "${MasterDef[StandalonePatch]}" != "false" ]]; then
		echo "ERROR: Master Definition file ($masterDefFile) has an invalid value for 'StandalonePatch'."
		echo "  Expected either 'true' or 'false', instead value was '${MasterDef[StandalonePatch]}'"
		exit 1
	fi

	# If we're forcing patch install and forcing a particular list of patches, validate that the passed list of patchnames is valid (matches the list)

	# XXX - logic

}


function parse_patch_details {

	# Read in various patch properties from md5sum file and patch definition file

	local patchName="$1"


	#if [[ $(isBaseRelease "${patchName}") -eq 0 ]]; then


	local patchDefFile="${SCRIPTDIR}/patch_defs/${patchName}.def"

	debug_print "Reading patch definition file '${patchDefFile}'"
	debug_print ""

	if [[ "$patchDefFile" == "" ]]; then
		printFail
		echo "ERROR:  parse_patch_details():  No patch definition filename specified.  Exiting"
		exit 1
	fi

	if [[ ! -f "$patchDefFile" ]]; then
		printFail
		echo "ERROR:  parse_patch_details(): Patch definition filename (${patchDefFile}) does not exist.  Exiting."
		exit 1
	fi

	# Retrieve values

	PatchDef["${patchName}-PatchID"]="$(cat ${patchDefFile} | $JQ '.idPatches' -r)"
	#echo "PatchID: ${PatchDef[${patchName}-PatchID]}"

	if [[ "${PatchDef[${patchName}-PatchID]}" == "" ]]; then
		printFail
		echo "ERROR:  Could not read patch definition file (${patchDefFile}), or file invalid.  Property 'PatchID' could not be read. Exiting."
		exit 1
	fi




	# Store patch definition info in common variables.

	PatchDef["${patchName}-Patch_Name"]="$(cat ${patchDefFile} | $JQ '.Patch_Name' -r)"
	#PatchDef["${patchName}-Depends_On"]="$(cat ${patchDefFile} | $JQ '.Depends_On' -r)"
	PatchDef["${patchName}-Comment"]="$(cat ${patchDefFile} | $JQ '.Comment' -r | tr -d "'")"
	#**PatchDef["${patchName}-Files"]="$(cat ${patchDefFile} | $JQ '.FilesArray' -r | $JQ '.[]' -r)"
	#PatchDef["${patchName}-MD5Sums"]="$(cat ${patchDefFile} | $JQ '.MD5Array' -r | $JQ '.[]' -r)"
	#PatchDef["${patchName}-DestDirs"]="$(cat ${patchDefFile} | $JQ '.InstallLocationsArray' -r | $JQ '.[]' -r)"
	PatchDef["${patchName}-Services"]="$(cat ${patchDefFile} | $JQ '.ServicesArray' -r | $JQ '.[]' -r)"
	#PatchDef["${patchName}-DestDirs"]="$(cat ${patchDefFile} | $JQ '.Install_Locations' -r | $JQ '.[]' -r)"
	#SERVICES="$(cat ${patchDefFile} | $JQ '.Services' -r)"
	#**local PATCH_FILES=($(cat ${patchDefFile} | $JQ '.FilesArray' -r | $JQ '.[]' -r))
	#**local MD5SUMS=($(cat ${patchDefFile} | $JQ '.MD5Array' -r | $JQ '.[]' -r))
	#local MD5SUMS=($(cat ${patchDefFile} | $JQ '.MD5sums' -r | $JQ '.[]' -r))
	#**local DESTDIRS=($(cat ${patchDefFile} | $JQ '.InstallLocationsArray' -r | $JQ '.[]' -r))
	PatchDef["${patchName}-PreScript"]="$(cat ${patchDefFile} | $JQ '.PreScript' -r)"
	PatchDef["${patchName}-PostScript"]="$(cat ${patchDefFile} | $JQ '.PostScript' -r)"



	for key in "${!PatchDef[@]}"; do # Debugging
		debug_print "\t${key}: ${PatchDef[$key]}"
	done
	debug_print ""


	# Read in the file list and md5sum info, stored in an md5sum file

	unset _patch_md5sums; declare -A _patch_md5sums # declare/reset temp array used for this loop only
	if [[ $(isBaseRelease "${patchName}") -eq 1 && $DAREENABLED -eq 0 ]]; then # if we're parsing the master patch and DARE is disabled
		md5sum_filename="$SCRIPTDIR/md5sums/${patchName}.MD5SUMS.nondare"
	else
		md5sum_filename="$SCRIPTDIR/md5sums/${patchName}.MD5SUMS"
	fi

	output="$(cat "$md5sum_filename")"
	parse_md5sum _patch_md5sums "$output"

	# Verify installable files are present and md5sums are correct, store their names and values in arrays:

	local FilesDir="${SCRIPTDIR}/files/${PatchDef[${patchName}-Patch_Name]}" # e.g. /home/admin/STRG-12345-Customer/patch_files/STRG-23456-Customer/

	for _filename in ${!_patch_md5sums[@]}; do
		PatchDef["${patchName}-Files"]+=" $_filename" # includes path on system, like /opt/storageos/lib/storageos-cm.jar
		Patch_MD5SUMS["${patchName}-${_filename}"]="${_patch_md5sums[$_filename]}"
		#echo "Setting Patch_MD5SUMS[${patchName}-${_filename}]=${_patch_md5sums[$_filename]}"

		# Check is present in the bundle

		if [[ $(isBaseRelease "$patchName") -eq 0  ]]; then  # Don't check if this is the base release definition
			local _SHORTNAME="$(basename "$_filename")"
			local _FILE_IN_BUNDLE="${FilesDir}/${_SHORTNAME}"

			if [[ ! -r "$_FILE_IN_BUNDLE" ]]; then
				printFail
				echo "ERROR: Could not find file in patch bundle"
				echo
				echo "A file named '$_SHORTNAME' is defined in the patch bundle for patch '${patchName}'"
				echo
				echo "This file was expected to be found at '$_FILE_IN_BUNDLE', but it was not found or could not be read."
				echo
				echo "This is an unexpected error - exiting."
				exit 1
			fi
		fi

	done


	# If this is the base release definition, do a sanity check there's at least oneguaranteed entry.
	# We do this to help protect against mistakes leading to no entries populated, which could allow sanity checking to essentially be skipped, silently

	if [[ $(isBaseRelease "$patchName") -eq 1  ]]; then
		if [[ "${Patch_MD5SUMS["${patchName}-/opt/storageos/lib/storageos-blobsvc.jar"]}" == "" ]]; then
			printFail
			echo "ERROR: Did not read any md5sum entries for the base release."
			echo
			echo "To validate the currently installed patches and look for potential (dangerous) conflicts, md5sum of core files"
			echo "is expected to be stored in '${md5sum_filename}'."
			echo
			echo "No entries were read from this file."
			echo
			echo "This is an unexpected error - exiting."
			exit 1
		fi
	fi


	#for key in "${!PATCH_FILES[@]}"; do

	#	local PATCH_FILE="${PATCH_FILES[$key]}" # Includes path on system, like /opt/storageos/lib/storageos-cm.jar
	#	local DESTDIR="${DESTDIRS[$key]}"
	#	local FILENAME="$(basename "$PATCH_FILE")"  # Just the short name, like storageos-cm.jar
	#	local TEMP_MD5SUM="${MD5SUMS[$key]}"
	#	local FULL_PATH="${FilesDir}/${FILENAME}"   # Local path+name of file within the patch bundle

	#	PatchDef["${patchName}-MD5Sums"]

	#	patch_md5sums["${patchName}_${DESTDIR}/${FILENAME}"]="$TEMP_MD5SUM"

		# Check file exists in the bundle and its md5sum is correct (removing as is unnecessary and doesn't provide useful redundancy to catch problems
	#	if [[ $(isBaseRelease "$patchName") -eq 0  ]]; then  # Skip checking if this is the base release def; we use this info only for checking, not installing anything from the bundle

	#		if [[ ! -r "$FULL_PATH" ]]; then
	#			printFail
	#			echo "ERROR: Could not read patch file '$FULL_PATH'"
	#			exit 1
	#		fi

	#		CUR_MD5SUM="$(md5sum $FULL_PATH | awk '{ print $1 }')"

	#		if [[ "$CUR_MD5SUM" != "$TEMP_MD5SUM" ]]; then
	#			printFail
	#			echo "ERROR: parse_patch_details: File '$PATCH_FILE' has md5sum of '$CUR_MD5SUM', but '$TEMP_MD5SUM' was expected."
	#			exit 1
	#		fi
	#	fi
	#done

	# Check if Pre and Post scripts, if specified, are present:

	for Script in "${PatchDef[${patchName}-PreScript]}" "${PatchDef[${patchName}-PostScript]}"; do

		debug_print "Checking for patch pre-, or post-processing script ${Script}"

		if [[ "$Script" != "" && "$Script" != "null" ]]; then
			if [[ ! -f "${FilesDir}/${Script}" ]]; then
				printFail
				echo "ERROR: parse_patch_details: File ${FilesDir}/${Script} was specified in patch definition, but not found"
				exit 1
			fi
		fi
	done

}

function show_summary {
	# Display a summary of the operation about to be run, and prompt for
	# confirmation before continuing.  Confirmation can be skipped with
	# a CLI option.


	# Depending on whether nodes are identical or not (some need more patches than others),
	# Display either per-node or consolidated output

	# Check installed patches on each node, see if they differ
	local node_desync=0
	local temp_patchlist=""
	local temp_nodelist=""
	for NODE in $NODES; do
		if [[ "$temp_patchlist" == "" ]]; then
			temp_patchlist="${installed_patches[$NODE]}"
			temp_nodelist="$NODE"
		else
			if [[ "${installed_patches[$NODE]}" != "$temp_patchlist" ]]; then
				node_desync=1 # Nodes are not identical
			fi
		fi
	done

	if [[ $node_desync -eq 1 ]]; then
		temp_nodelist="$NODES"
	fi


	# Set a string for slight grammar change in outputs depending on whether we're installing a patch or just listing what's installed.
	if [[ "$SHOWINSTALLED" -eq 0 ]]; then # Installing, not just listing what's installed
		INSTALLPHRASE="will"
	else
		INSTALLPHRASE="need to"
	fi



	# XXX - Go through this and make safe for manual mode


	if [[ $node_desync -eq 0 ]]; then # Nodes are in sync, display a verbose output (most common output)

		echo "Patches/releases currently installed:"
		echo ""
		if [[ $dependencycheck -ne 0 ]]; then
			echo "     NOTE:  Unexpected files exist on each node. The following list is a best guess"
			echo "       and may not be 100% accurate"
			echo ""
		fi
		for patch in ${installed_patches[$NODE]}; do
			PatchID="$(get_patch_property "$patch" "PatchID")"
			PatchDesc="$(get_patch_property "$patch" "Comment")"
			if [[ $(isBaseRelease "$patch") -eq 1 ]]; then
				printf "${OKColor}%-30s${ENDColor} (Base release)\n" $patch
			else
				printf "${OKColor}%-30s${ENDColor} (PatchID: %s)" $patch $PatchID
				#echo -e "${OKColor}$patch${ENDColor} (PatchID: $PatchID)"
				echo -e "\t${GREYColor}$PatchDesc${ENDColor}"
			fi
		done
		if [[ $dependencycheck -ne 0 ]]; then
			echo -e "${SKIPColor}(Unknown files installed, can't determine base rev)${ENDColor}"
		fi

		if [[ $SHOWINSTALLED -eq 1 ]]; then # Just show the installed patches and exit
			return 0
		fi


		echo
		#echo "Number of patches that need to be installed:  ${#patches_to_install[@]}"
		#echo ""
		echo "About to perform the following patch install:"
		echo ""
		if [[ $MANUALMODE -eq 0 ]]; then # We've loaded data from a definition file
			for patch in ${patches_to_install[$NODE]}; do
				PatchID="$(get_patch_property "$patch" "PatchID")"
				PatchDesc="$(get_patch_property "$patch" "Comment")"

				# Determine if patch is already installed and is being reinstalled - mark slightly different text
				# if so

				ExtraText=""
				for installed_patch in ${installed_patches[$NODE]}; do
					if [[ "$patch" == "$installed_patch" ]]; then
						ExtraText="(re-install) "
					fi
				done



				#if [[ "$patch" == "${MasterDef[PrimaryPatch]}" ]]; then
				#	printf "%-30s$ (PatchID: %s)" $patch $PatchID
				#else
					printf "${SKIPColor}%-30s${ENDColor} (PatchID: %s)" $patch $PatchID
				#fi
				echo -e "\t$ExtraText${GREYColor}$PatchDesc${ENDColor}"

			done
		fi
		echo

		if [[ ${#files_to_install[@]} -gt 0 && ${files_to_install[0]} != "None" ]]; then
			echo "Files that $INSTALLPHRASE be installed:"

			for file in ${files_to_install[$NODE]}; do
				printf "\t%-55s (from ${files_to_install_version[${NODE}_${file}]})\n" $file
				#echo -e "\t${file} (from ${files_to_install_version[$key]})"
		#		echo -e "\t${file} ${MD5SUMS[$key]} ${DESTDIRS[$key]}"
			done
		else
			echo "No files $INSTALLPHRASE be installed."
			echo ""
		fi
		echo ""

		if [[ ${#services_to_restart[@]} -gt 0 && ${services_to_restart[0]} != "None" ]]; then
			echo "The following services $INSTALLPHRASE be restarted: "
			for service in ${services_to_restart[$NODE]}; do
				echo -e "\t${service}"
			done
			echo ""
		else
			echo "No services $INSTALLPHRASE be restarted."
			echo ""
		fi
	else # if nodes are not in sync, show a more consolidated summary (otherwise can be too much output to realistically expect users to parse)
		echo "All nodes currently do not have the same patches installed."
		echo
		echo "Patches currently installed:"
		if [[ $dependencycheck -ne 0 ]]; then
			echo "     NOTE:  Unexpected files exist on each node. The following list is a best guess"
			echo "       and may not be 100% accurate"
			echo ""
		fi
		for NODE in $NODES; do
			echo -e -n "\t$NODE: ${OKColor}"
			for patch in ${installed_patches[$NODE]}; do
				echo -n "$patch "
			done
			echo -e "${ENDColor}"
		done
		if [[ $SHOWINSTALLED -eq 1 ]]; then # Just show the installed patches and exit
			return 0
		fi

		echo
		echo "Patches that $INSTALLPHRASE be installed:"
		for NODE in $NODES; do
			echo -e -n "\t$NODE: ${SKIPColor}"
			if [[ "${patches_to_install[$NODE]}" == "" ]]; then echo -n "<None>"; fi
			for patch in ${patches_to_install[$NODE]}; do
				echo -n "$patch "
			done
			echo -e "${ENDColor}"
		done
		echo
		echo "Files that $INSTALLPHRASE be installed:"
		for NODE in $NODES; do
			echo -e -n "\t$NODE: ${SKIPColor}"
			if [[ "${files_to_install[$NODE]}" == "" ]]; then echo -n "<None>"; fi
			for file in ${files_to_install[$NODE]}; do
				echo -n "$(basename $file) "
			done
			echo -e "${ENDColor}"
		done
		echo
		echo "Services that $INSTALLPHRASE be restarted:"
		for NODE in $NODES; do
			echo -e -n "\t$NODE: ${SKIPColor}"
			if [[ "${services_to_restart[$NODE]}" == "" ]]; then echo -n "<None>"; fi
			for service in ${services_to_restart[$NODE]}; do
				echo -n "$service "
			done
			echo -e "${ENDColor}"
		done

	fi
	if [[ "${MasterDef[StandalonePatch]}" == "true" ]]; then
		echo "Patch Type:                                                     Standalone"
	fi
	echo "Number of nodes:                                                $NUMNODES"
	echo "Number of seconds to wait between restarting node services:     $NODE_DELAY"
	echo "Check DT status between node service restarts:                  $DTCHECK"

}

function execute_container_cmd {
	local _NODE=$1
	local _CMDS=$2
	local _HandleError=$3

	if [[ "$_HandleError" == "" ]]; then
		HandleError=1
	fi

	_CMDS="$(escapequotes ${_CMDS})"

	log_debug_message "Executing container command '${_CMDS}' on $NODE"

	#PID=`ssh $_NODE sudo docker inspect --format "{{.State.Pid}}" object-main 2>&1`

	#if ! [[ "$PID" =~ $re ]]; then # Check if PID is numeric
	#	echo "ERROR:  Unable to retrieve object-main container PID for node $_NODE" >&2
	#	$ECHO "\t Value returned: '${PID}'" >&2
	#	exit 1
	#fi

	#ssh $_NODE sudo nsenter --target $PID --mount --uts --ipc --net --pid sudo ${_CMDS}
	log_debug_message "Full command:  ssh $_NODE sudo docker exec object-main \"sh -c '${_CMDS}'\""
	ssh $_NODE sudo docker exec object-main "sh -c '${_CMDS}'"
	retval=$?

	if [[ $retval -ne 0 && $_HandleError -eq 1 ]]; then
		echo "ERROR:  Command run against remote system exited with non-zero status." >&2
		echo -e "\tCommand run: ssh $_NODE sudo docker exec object-main 'sh -c "${_CMDS}"'" >&2
		echo -e "\tReturn status: $retval" >&2
		exit 1
	fi

}

function container_cp {

	# Copy files from the local machine to the object-main container on a given node.
	#
	# File is first scp-ed to /tmp on the node (which may be the current one)
	# File is copied from the parent OS on the node to the object container with "docker cp"

    local _NODE=$1
    local _SOURCEFILE="$2" # Complete path within the patch bundle, e.g. /home/admin/STRG-12345/files/STRG-23456/storageos-blobsvc.jar
    local _DESTDIR="$3"
	local _EXPECTED_MD5SUM="$4" # Optional

	local _FILENAME="$(basename $_SOURCEFILE)" # Short name, e.g. storageos-blobsvc.jar
	local _DESTFILE="${_DESTDIR}/${_FILENAME}" # (i.e. /opt/storageos/bin/storageos-stat.jar)
	local _TEMPFILE="/tmp/${_FILENAME}" # Location on each node to copy the file to temporarily before
	                                      # moving the file into the container

	if [[ ! -f "$_SOURCEFILE" ]]; then
		echo "ERROR:  container_cp:  Source file ($_SOURCEFILE) does not exist or is not a file"
		exit 1
	fi

	if [[ ! -r "$_SOURCEFILE" ]]; then
		echo "ERROR:  container_cp:  Source file ($_SOURCEFILE) is not readable"
		exit 1
	fi

	local SOURCE_MD5SUM="$(md5sum "$_SOURCEFILE" | awk '{ print $1 }')"

	if [[ "$SOURCE_MD5SUM" == "" ]]; then
		echo "ERROR: container_cp: Could not determine md5sum of source file ($_SOURCEFILE)"
		exit 1
	fi
	if [[ "$_EXPECTED_MD5SUM" != "" && "$_EXPECTED_MD5SUM" != "$SOURCE_MD5SUM" ]]; then
		echo "ERROR: container_cp: Source md5sum ($SOURCE_MD5SUM) does not match expected md5sum ($_EXPECTED_MD5SUM)"
		exit 1
	fi


	# Copy file to the destination node

	sudo scp -q "$_SOURCEFILE" "${_NODE}:${_TEMPFILE}"

	local TEMP_MD5SUM="$(ssh $_NODE "md5sum '${_TEMPFILE}' | awk '{ print \$1 }'")"

	if [[ "$SOURCE_MD5SUM" != "$TEMP_MD5SUM" ]]; then
		echo "ERROR: container_cp:  md5sum after copying to node is incorrect.  Expected '$SOURCE_MD5SUM', got '$TEMP_MD5SUM'"
		exit 1
	fi


	# Copy file from tempdir to destination dir

	ssh $_NODE "sudo docker cp ${_TEMPFILE} object-main:${_DESTFILE}"

	DEST_MD5SUM="$(execute_container_cmd $_NODE "md5sum '$_DESTFILE' | awk '{ print \$1 }'")" # Checking move completed properly and validity of file in one swoop

	if [[ "$SOURCE_MD5SUM" != "$DEST_MD5SUM" ]]; then
		echo "ERROR: container_cp:  md5sum after copying file ($_FILENAME) into container is incorrect.  Expected '$SOURCE_MD5SUM', got '$DEST_MD5SUM'"
		exit 1
	fi

}



function check_dt_status {

	local _NODE="$1"

	print_message 0 "Waiting for DTs to come online"

	V_IP=$(netstat -an | grep ":9101" | grep LISTEN | awk '{ print $4 }' | awk -F : '{ print $1 }')
	if [[ "$V_IP" == "" ]]; then
		print_message 0 "ERROR:  Could not determine IP address listening on port 9101 \(dtquery\).  Is dtquery not running on this node?"
		exit 1
	fi
	if [[ ! "$V_IP" == *'.'*'.'*'.'* ]]; then
		print_message 0 "ERROR:  Attempt to determine dtquery listening IP failed - IP address is invalid.  Value returned: '$V_IP'"
		exit 1
	fi

	local i=0
	local passed=0

	while [[ $i -lt $MAX_DT_CHECK ]]; do
		(( i+=1 ))
		print_message 1 "Checking DT stats, pass $i of $MAX_DT_CHECK"
		DT_Output="$(curl -s -m $MAX_DT_WAIT http://${V_IP}:9101/stats/dt/DTInitStat | sed -e 's/<\//##/g' -e 's/</\n</g' -e 's/##/<\//g')"
		if [[ $? -eq 0 && "$DT_Output" != "" ]]; then
			unready_dt_num=$(echo "$DT_Output" | grep unready_dt_num | head -n 1 | tr '<>' ' ' | awk ' {print $2} ')
			unknown_dt_num=$(echo "$DT_Output" | grep unknown_dt_num | head -n 1 | tr '<>' ' ' | awk ' {print $2} ')

			print_message 1 "\tUnready DTs: $unready_dt_num  Unknown DTs: $unknown_dt_num"
			if [[ ${unready_dt_num} =~ ${re} ]] &&  [ "$unready_dt_num" -eq 0 ]; then
				passed=1
				print_message 1 "\tDT check passed\n"
				break
			fi
		else
			print_message 1 "\tDT check failed or returned no output"
		fi

		sleep 20
	done

	if [[ $passed -eq 0 ]]; then
		echo "ERROR: DT Check failed.  DTs did not come ready or could not be checked after several passes."
		exit 1
	fi

}

function validate_bundle_consistency {

	# Check the md5sums of all the files in this bundle against a master MD5SUM file, checking patch consistency

	cd "$SCRIPTDIR" # Ensure we're in the proper dir.

	MD5SUMFile="./MD5SUMS.bundle"


	if [[ ! -f "$MD5SUMFile" ]]; then
		printFail
		echo "ERROR: Could not locate md5sum file: MD5SUMFile"
		exit 5
	fi

	output="$(md5sum -c "$MD5SUMFile" --quiet 2>&1)"

	if [[ "$output" != "" ]]; then
		printFail
		echo "Patch bundle onsistency check failed - md5sums for one or more files"
		echo "in the patch bundle were invalid, or files were not found."
		echo ""
		echo "$SCRIPTNAME will attempt to validate files in the patch using $MD5SUMFile, which"
		echo "is bundled with the patch."
		echo ""
		echo "Output from md5sum was:"
		echo "$output"
		exit 6
	fi


}

function printDone() {
	echo -e "${OKColor}DONE${ENDColor}"
}

function printFail() {
	echo -e "${FAILColor}FAILED${ENDColor}"
}

function printSkip() {
	if [[ $1 -eq 1 ]]; then # Don't print a newline
		echo -n -e "${SKIPColor}SKIPPED${ENDColor}"
	else
		echo -e "${SKIPColor}SKIPPED${ENDColor}"
	fi
}


# -------------------- Main program logic begins here --------------------
#


echo "$SCRIPTNAME Version ${VERSION}"
echo ""
parse_args $*

parse_MACHINES "$MACHINES"  # Builds "$NODES" list

make_patch_dirs  # Create patch directories in caspian on node, for log files, etc

# Validate md5sums of patch if running in automatic mode (installing patch bundle)

if [[ $MANUALMODE -eq 0 ]]; then

	echo -n "Verifying patch bundle consistency..."

	validate_bundle_consistency

	# XXX - error handling

	printDone
fi

check_dare

# Read in the master def file (defines the patch list) and definition of each patch in the patch list (the latest patch and all previous since GA release)
echo -n "Reading in patch details..."
#output="$(parse_master_def_file "${SCRIPTDIR}/master.def")"
parse_master_def_file "${SCRIPTDIR}/master.def"
retval=$?
if [[ $retval != 0 ]]; then
	printFail
	echo "$output"
	exit $retval
else
	printDone
fi

# Check nodes are online

echo -n "Validating nodes are online..."
for NODE in $NODES; do
	# Currently we just execute a basic command in the container of each node
	# to verify it's online and ready to accept patches.
	# This confirms the node is reachable, container is loaded and running.
	teststring=":patchtest:"

	output="$(execute_container_cmd $NODE "echo $teststring")"

	if [[ ! "$output" == "$teststring" ]]; then
		printFail
		echo "ERROR: Could not execute commands on the object-main container on $NODE"
		echo "  Expected '$teststring', output was '$output'"
		exit 1
	fi

	SUMMARY="--------------------Patch started --------------------------\n"

	SUMMARY="${SUMMARY}$(show_summary 0)"

	log_message 0 "$SUMMARY"

done # Validate node health
printDone

# Check if we're running a dare-enabled release or not (sets "DAREENABLED" global)
check_dare

# Check installed patches and verify dependencies, if any

if [[ $MANUALMODE -eq 0 ]]; then

	echo -n "Checking Installed Patches and Dependencies..."

	if [[ $FORCE_INSTALL -ne 1 && "${MasterDef[StandalonePatch]}" == "false" ]]; then
		check_installed_patches # sets $installed_patches
		dependencycheck=$?

		if [[ $dependencycheck -ne 0 ]]; then
			printFail

			SHOWINSTALLED=1
			echo
			show_summary
			echo

			echo -e "ERROR: Checking existing patches failed."

			if [[ $dependencycheck -eq 2 ]]; then
				echo "Unexpected version of files installed:"
				echo ""
				printf "%-23s%-50s%-30s\n" "Node" "File" "MD5Sum on Node"
				echo -e "$dependency_error"
				echo ""
				echo -e "${FAILColor}ERROR: Checking existing patches failed.${ENDColor}"
				echo ""
				echo "System is not running the expected code, or has had patches or other changes"
				echo "  applied that are unexpected."
			elif [[ $dependencycheck -eq 3 ]]; then
				echo "File(s) to be patched could not be found.  Could not determine ownership or permission info"
				echo ""
				echo "This may mean that the patch was created improperly, with the wrong path info.  Verify the path of the file is correct - the patch may need to be fixed and regenerated."
				echo ""
				echo "If this is a brand new file that does not exist on the system yet, this may be normal."
				echo "To work around, create a version of the file in the object container and set the appropriate ownership and permission info."
				echo ""
				echo -e "$filenotfound_error"
			elif [[ $dependencycheck -eq 4 ]]; then
				echo -e "$sanitycheck_error"

			fi
			exit $dependencycheck
		fi
		printDone
	else # Skip checking installed patches, either we are forcing install or this is a standalone patch (no dependency history included).
		#if [[ $FORCE_INSTALL -eq 1 ]]; then # assume only the base release is installed to force install of all patches in the chain
			for NODE in $NODES; do
				installed_patches[$NODE]="${MasterDef[BaseRelease]}"
			done
			printSkip
		#fi
	fi
fi

get_patches_to_install # Sets $patches_to_install
get_install_files # Sets $files_to_install and $files_to_install_version
get_restart_services # Sets $services_to_restart
get_pre_scripts # Sets $pre_script
get_post_scripts # Sets $post_script


if [[ 0 -eq 1 ]]; then
	echo "Patches installed:"
	for NODE in $NODES; do
		echo "${NODE}:"
		for patch in ${installed_patches[$NODE]}; do
			echo -e "\t$patch"
		done
	done

	echo
	echo "Patches to install:"
	for NODE in $NODES; do
		echo "${NODE}:"
		for patch in ${patches_to_install[$NODE]}; do
			echo -e "\t$patch"
		done
	done


	echo
	echo "Files to install:"
	for NODE in $NODES; do
		echo "${NODE}:"
		for file in ${files_to_install[$NODE]}; do
			echo -e "\t$file (from ${files_to_install_version[${NODE}_${file}]})"
		done
	done

	echo
	echo "Services to restart:"
	for NODE in $NODES; do
		echo "${NODE}:"
		for service in ${services_to_restart[$NODE]}; do
			echo -e "\t$service"
		done
	done
fi

# Display what we're about to run, ask for confirmation

echo
show_summary

if [[ $SHOWINSTALLED -eq 1 ]]; then # Just show the installed patches and exit
	exit 0
fi

# If there is something to install,prompt the user to continue.  If not, then exit.

echo
if [[ ${#patches_to_install[@]} -gt 0 ]]; then
	# Wait for user input to continue
	while true; do
		read -p "Do you wish to continue (y/n)?" yn
		case $yn in
			[Yy]* ) break;;
			[Nn]* ) exit;;
			* ) echo "Please answer yes or no.";;
		esac
	done
else # No patches to install
	log_message 0 "No patches need installed - system is up to date.  Exiting."
	echo -e "${SKIPColor}No patches need installed - system is up to date.  Exiting.${ENDColor}"
	exit 0
fi


# Start processing each node:

for NODE in $NODES; do


	# Distribute file(s)

	if [[ "${files_to_install[$NODE]}" == "" ]]; then
		echo "No files to install on $NODE"
	else
		echo "Distributing files to node $NODE"
		for file in ${files_to_install[$NODE]}; do
			PATCH_FILE="$file" # Full filename, e.g. /opt/storageos/lib/storageos-stat.jar
			FILENAME="$(basename "$PATCH_FILE")" # Short filename, e.g. storageos-stat.jar
			DESTDIR="$(dirname "$PATCH_FILE")" # Final path in container (i.e. /opt/storageos/bin)
			PATCH_VERSION="${files_to_install_version[${NODE}_${file}]}" # Version of file to copy, e.g. which patch dir within the bundle we're pulling it from
			SOURCEDIR="${SCRIPTDIR}/files/$PATCH_VERSION"   # Path within the patch bundle to copy from
			MD5SUM="$(md5sum "${SOURCEDIR}/${FILENAME}" | awk '{ print $1 }')"  # We should have already validated the file is valid, but should we be comparing gainst the definition file again...?
			sourcefullpath="${SOURCEDIR}/${FILENAME}"
			finalfullpath="${DESTDIR}/${FILENAME}" # Final, full path of file inside container (i.e. /opt/storageos/bin/storageos-stat.jar)
			backupfullpath="${finalfullpath}.${TSTAMP}" # Rename original file to filename+timestamp


			# Check for original file(s) on destination

			FILEDETAILS="$(execute_container_cmd $NODE "ls -al '$finalfullpath'")"

			debug_print "ls -al $finalfullpath returns"
			debug_print "$FILEDETAILS"

			# Get original file(s) permissions+ownership

			ORIGPERMS="$(echo "$FILEDETAILS" | awk '{ print $1 }')"
			ORIGUSER="$(echo "$FILEDETAILS" | awk '{ print $3 }')"
			ORIGGROUP="$(echo "$FILEDETAILS" | awk '{ print $4 }')"

			if [[ "$ORIGPERMS" == "" || "$ORIGUSER" == "" || "$ORIGGROUP" == "" ]]; then
				echo "ERROR: Could not determine permissions for original file."
				echo -e "\tORIGPERMS='$ORIGPERMS' ORIGUSER='$ORIGUSER' ORIGGROUP='$ORIGGROUP'"
				exit 1
			fi

			# XXX - should sanity check before we continue and make any change - that destination file exists, check again that source exists, etc)
			#       Need to be as sure as possible that things will succeed before we continue to avoid leaving in a partially-complete state


			# Back up original file

			execute_container_cmd $NODE "mv '$finalfullpath' '$backupfullpath'"

			FILEDETAILS="$(execute_container_cmd $NODE "ls -al '$backupfullpath'")"

			# XXX - execute_container will exit if the file isn't found - do we want a more specific error?

			# Distribute patch file to container

			container_cp $NODE "${sourcefullpath}" "$DESTDIR" "$MD5SUM"

			# Copy permissions from original file to new file

			execute_container_cmd $NODE "chmod --reference '$backupfullpath' '$finalfullpath'"
			execute_container_cmd $NODE "chown --reference '$backupfullpath' '$finalfullpath'"

			# Validate permissions (MD5sum already verified in container_cp)

			NEWFILEDETAILS="$(execute_container_cmd $NODE "ls -al '$finalfullpath'")"

			NEWPERMS="$(echo "$NEWFILEDETAILS" | awk '{ print $1 }')"
			NEWUSER="$(echo "$NEWFILEDETAILS" | awk '{ print $3 }')"
			NEWGROUP="$(echo "$NEWFILEDETAILS" | awk '{ print $4 }')"

			if ! [[ "$ORIGPERMS" == "$NEWPERMS" || "$ORIGUSER" == "$NEWUSER" || "$ORIGGROUP" == "$NEWGROUP" ]]; then
				echo "ERROR: Permissions on new file don't match expected."
				echo -e "\tExpected:  $ORIGPERMS $ORIGUSER $ORIGGROUP"
				echo -e "\tReceived:  $NEWPERMS $NEWUSER $NEWGROUP"
				exit 1
			fi
		done # Copy each file to container
	fi # If there are files to install
done # Loop through each node pushing files

# If all files distributed successfully to all nodes, move on to restart services

echo
for NODE in $NODES; do
	if [[ "${services_to_restart[$NODE]}" == "" ]]; then
		echo "No services to restart on $NODE"
	else
		echo "Restarting services on $NODE"

		for SERVICE in ${services_to_restart[$NODE]}
		do

			# Restart service

			if [[ "$SERVICE" == "ALL" ]]; then
				# If all services need restarted, run the actual dataservice init script

				echo -e "\tRestarting all services"

				ssh $NODE "sudo docker exec object-main sh -c 'cd /etc/init.d/; ./storageos-dataservice restart 2>&1 '" | grep -v "no such service cron"

				# XXX - figure out how to wait until everything's good to proceed
			else
				echo -e "\tRestarting $SERVICE"
				# Get PID of service
				PID="$(execute_container_cmd $NODE "pidof $SERVICE")"

				if [[ "$PID" != "" && "$PID" =~ $re ]]; then
					# Kill service, which will be restarted automatically
					$(execute_container_cmd $NODE "kill -9 $PID")
				fi

				# Wait for service to restart, up to $SVC_TIMEOUT seconds; if service doesn't
				# restart in time, do fatal abort

				CUR_DATE="$(date +%s)"
				(( TIMEOUT_DATE=CUR_DATE+SVC_TIMEOUT ))

				restarted=0

				while [[ $CUR_DATE -lt $TIMEOUT_DATE ]]; do
					NEWPID="$(execute_container_cmd $NODE "pidof $SERVICE")"

					if [[ "$NEWPID" != "" && "$NEWPID" =~ $re && "$NEWPID" != "$PID" ]]; then
						# If the service has restarted ($NEWPID has an integer value, and
						#   the PID has changed, exit the monitor loop
						restarted=1
						break;
					fi

					sleep 2 # seconds between service restart checks
					CUR_DATE="$(date +%s)"

				done  # Wait for service to restart, up to timeout

				if [[ $restarted -eq 0 ]]; then
					echo "Service '$SERVICE' failed to restart before the timeout of '$SVC_TIMEOUT' seconds"
					exit 1
				fi

			fi # if service is "ALL" or something else, perform restart action

			sleep $SERVICE_DELAY # Wait a period after the service has started to give it time to start
			                  # and stabilize
		done # Loop through each service

		echo -n "Waiting $NODE_DELAY seconds for services to stabilize..."
		sleep $NODE_DELAY # Wait a short period after each node's services have restarted
		printDone

		#   Check DTs are stable before continuing, if specified

		if [[ "$DTCHECK" == "true" ]]; then
			check_dt_status "$NODE"
		fi

	fi # If there are services to restart

done # Loop through each node


# Log completion/summary messages on each node

log_message 0 "Patching complete."
echo
echo -e "${OKColor}Patching complete.${ENDColor}"
